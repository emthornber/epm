diff --git a/tmp/epm/CHANGES.md b/./epm/CHANGES.md
index e340707..2c342e7 100644
--- a/tmp/epm/CHANGES.md
+++ b/./epm/CHANGES.md
@@ -12,8 +12,6 @@ Changes in EPM 4.5.1
 Changes in EPM 4.5
 ------------------
 
-- Dropped support for AIX, AT&T (Solaris), Tru64, HP-UX, IRIX, LSB, and
-  Slackware packages.
 - "make install" failed due to the README filename changing (Issue #59)
 - The `mkepmlist` utility did not correctly handle filenames containing the
   `$` character (Issue #62)
@@ -26,6 +24,21 @@ Changes in EPM 4.5
 - Documentation updates (Issue #74, Issue #77)
 - Cleaned up old sprintf and strcpy usage in many places.
 
+Changes in EPM 4.4.2
+--------------------
+
+- Support Apache OpenOffice patches
+
+Changes in EPM 4.4.1
+--------------------
+
+- "make install" failed due to the README filename changing (Issue #59)
+- The `mkepmlist` utility did not correctly handle filenames containing the
+  `$` character (Issue #62)
+- The configure script incorrectly substituted "NONE" for the installation
+  prefix (Issue #67)
+- Cleaned up old sprintf and strcpy usage in many places.
+
 
 Changes in EPM 4.4
 ------------------
diff --git a/tmp/epm/INSTALL.md b/./epm/INSTALL.md
index dff967d..56e8546 100644
--- a/tmp/epm/INSTALL.md
+++ b/./epm/INSTALL.md
@@ -38,6 +38,12 @@ different location, use the `--prefix` option to the configure script:
     ./configure --prefix=/path/to/use ENTER
     make ENTER
 
+If using to build Apache OpenOffice, you will need to also include the `--enable-aoo`
+option, to activate those AOO specific changes:
+
+    ./configure --enable-aoo ENTER
+    make ENTER
+
 Once EPM is compiled you can type:
 
     sudo make install ENTER
diff --git a/tmp/epm/Makefile.in b/./epm/Makefile.in
index 4f31584..1e4be86 100644
--- a/tmp/epm/Makefile.in
+++ b/./epm/Makefile.in
@@ -86,18 +86,24 @@ TARGETS		=	libepm.a \
 			epminstall \
 			mkepmlist \
 			@GUIS@
-EPM_OBJS	=	bsd.o \
+EPM_OBJS	=	aix.o \
+			bsd.o \
 			deb.o \
 			dist.o \
 			file.o \
+			inst.o \
 			macos.o \
+			pkg.o \
 			portable.o \
 			qprintf.o \
 			rpm.o \
 			run.o \
+			setld.o \
+			slackware.o \
 			snprintf.o \
 			string.o \
 			support.o \
+			swinstall.o \
 			tar.o
 SETUP_OBJS	=	setup.o \
 			setup2.o \
@@ -115,8 +121,6 @@ OBJS		=	epm.o \
 
 # Make all targets...
 all:	$(TARGETS) Makefile config.h
-
-
 # Clean all generated files...
 clean:
 	$(RM) $(OBJS)
@@ -132,6 +136,18 @@ distclean:
 	$(RM) epm.list
 
 
+#
+# Run the clang.llvm.org static code analysis tool on the C sources.
+#
+
+.PHONY: clang clang-changes
+clang:
+	$(RM) -r clang
+	scan-build -V -k -o `pwd`/clang $(MAKE) $(MFLAGS) clean all
+clang-changes:
+	scan-build -V -k -o `pwd`/clang $(MAKE) $(MFLAGS) all
+
+
 # Install all targets...
 install: all @INSTALL_GUIS@ @INSTALL_OSX@
 	echo Installing EPM programs in $(BUILDROOT)$(bindir)
@@ -139,7 +155,7 @@ install: all @INSTALL_GUIS@ @INSTALL_OSX@
 	for file in epm epminstall mkepmlist; do \
 		$(INSTALL) -c -m 755 $$file $(BUILDROOT)$(bindir); \
 	done
-	(cd doc; $(MAKE) $(MFLAGS) install)
+	#(cd doc; $(MAKE) $(MFLAGS) install)
 
 install-guis:	setup uninst
 	echo Installing EPM setup/uninst in $(BUILDROOT)$(libdir)/epm
@@ -210,12 +226,21 @@ test:	$(TARGETS)
 
 
 # Make distributions in different formats using EPM...
+aix: $(TARGETS)
+	./epm -f aix -v epm
+
 bsd: $(TARGETS)
 	./epm -f bsd -v epm
 
+slackware: $(TARGETS)
+	./epm -f slackware -v epm
+
 deb: $(TARGETS)
 	./epm -f deb -v epm
 
+inst tardist: $(TARGETS)
+	./epm -f tardist -v epm
+
 gui: $(TARGETS)
 	./epm -f portable -v -s default.png --setup-program setup \
 		--uninstall-program uninst --data-dir . epm
@@ -224,9 +249,14 @@ lsb macos portable rpm: $(TARGETS)
 	./epm -f $@ -v -s default.png --setup-program setup \
 		--uninstall-program uninst --data-dir . epm
 
+pkg: $(TARGETS)
+	./epm -f pkg -v epm
+
 native: $(TARGETS)
 	./epm -f native -v epm
 
+swinstall depot: $(TARGETS)
+	./epm -f depot -v epm
 
 # libepm.a
 libepm.a:	$(EPM_OBJS)
diff --git a/tmp/epm/README.md b/./epm/README.md
index 21b60e0..8a4efc7 100644
--- a/tmp/epm/README.md
+++ b/./epm/README.md
@@ -8,11 +8,17 @@ EPM is a simple cross-platform tool that generates software and patch
 distributions in various formats from a list of files.  Supported formats
 include:
 
+- AIX software packages ("installp")
+- AT&T software packages ("pkgadd"), used by Solaris and others
 - BSD packages ("pkg_create")
+- Compaq Tru64 UNIX ("setld")
 - Debian Package Manager ("dpkg")
+- HP-UX software packages ("swinstall")
+- IRIX software manager ("inst", "swmgr", or "tardist")
 - macOS software packages ("name.pkg")
 - Portable (installation and removal scripts with tar files)
 - Red Hat Package Manager ("rpm")
+- Slackware software packages ("name.tgz")
 
 EPM also includes graphical "setup" and "uninstall" programs that can be
 provided with your distributions to make installation and removal of more than
@@ -22,7 +28,13 @@ one package a snap.  The installers can be customized with product logos,
 EPM is provided as free software under version 2 of the GNU General Public
 license.
 
-> Note: This software is currently in maintenance mode.
+How is this releated to the official EPM?
+-----------------------------------------
+
+This version is a matched fork of that repo, but with Apache OpenOffice (and related)
+specific changes applied to the source code. These changes are only in effect if
+EPM is configured and built with the `--enable-aoo ` option. This version also
+continues to support platforms deprecated by the offical EPM.
 
 
 How Do I Compile EPM?
@@ -59,8 +71,8 @@ Resources
 
 The official home page for EPM is <https://www.msweet.org/epm>.
 
-Report all problems and submit all patches/pull requests using the Github issue
-tracking pages at <https://github.com/michaelrsweet/epm/issues>.
+Report all problems and submit all patches/pull requests for this version using the Github issue
+tracking pages at <https://github.com/jimjag/epm/issues>.
 
 
 Legal Stuff
diff --git a/./epm/aix.c b/./epm/aix.c
new file mode 100644
index 0000000..b4485e3
--- /dev/null
+++ b/./epm/aix.c
@@ -0,0 +1,926 @@
+/*
+ * AIX package gateway for the ESP Package Manager (EPM).
+ *
+ * Copyright 1999-2019 by Michael R Sweet
+ * Copyright 1999-2010 by Easy Software Products.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "epm.h"
+
+
+/*
+ * Directory information...
+ */
+
+typedef struct
+{
+  char	dst[1024];			/* Output directory */
+  int	blocks;				/* Size of files in this directory */
+} aixdir_t;
+
+
+/*
+ * Local functions...
+ */
+
+static int	aix_addfile(int type, const char *src, const char *dst,
+		            int num_dirs, aixdir_t **dirs);
+static void	aix_fileset(FILE *fp, const char *prodname, dist_t *dist,
+		            const char *subpackage);
+static char	*aix_version(const char *version);
+static int	write_liblpp(const char *prodname,
+		             const char *directory,
+		             dist_t *dist, int root,
+			     const char *subpackage);
+
+
+/*
+ * Local globals...
+ */
+
+static const char	*files[] =	/* Control files... */
+			{
+			  "al",
+			  "cfgfiles",
+			  "copyright",
+			  "inventory",
+			  "post_i",
+			  "pre_i",
+			  "unpost_i",
+                          "unpre_i"
+			};
+
+
+/*
+ * 'make_aix()' - Make an AIX software distribution package.
+ */
+
+int					/* O - 0 = success, 1 = fail */
+make_aix(const char     *prodname,	/* I - Product short name */
+         const char     *directory,	/* I - Directory for distribution files */
+         const char     *platname,	/* I - Platform name */
+         dist_t         *dist,		/* I - Distribution information */
+	 struct utsname *platform)	/* I - Platform information */
+{
+  int			i;		/* Looping var */
+  FILE			*fp;		/* Control file */
+  char			name[1024],	/* Full product name */
+			filename[1024],	/* Destination filename */
+			current[1024];	/* Current directory */
+  file_t		*file;		/* Current distribution file */
+  struct passwd		*pwd;		/* Pointer to user record */
+  struct group		*grp;		/* Pointer to group record */
+  const char		*runlevels;	/* Run levels */
+
+
+  REF(platform);
+
+  if (Verbosity)
+    puts("Creating AIX distribution...");
+
+  if (dist->release[0])
+  {
+    if (platname[0])
+      snprintf(name, sizeof(name), "%s-%s-%s-%s", prodname, dist->version,
+               dist->release, platname);
+    else
+      snprintf(name, sizeof(name), "%s-%s-%s", prodname, dist->version,
+               dist->release);
+  }
+  else if (platname[0])
+    snprintf(name, sizeof(name), "%s-%s-%s", prodname, dist->version, platname);
+  else
+    snprintf(name, sizeof(name), "%s-%s", prodname, dist->version);
+
+  getcwd(current, sizeof(current));
+
+ /*
+  * Write the lpp_name file for installp...
+  */
+
+  if (Verbosity)
+    puts("Creating lpp_name file...");
+
+  snprintf(filename, sizeof(filename), "%s/%s", directory, prodname);
+  make_directory(filename, 0755, 0, 0);
+
+  snprintf(filename, sizeof(filename), "%s/%s/lpp_name", directory, prodname);
+
+  if ((fp = fopen(filename, "w")) == NULL)
+  {
+    fprintf(stderr, "epm: Unable to create lpp_name file \"%s\": %s\n", filename, strerror(errno));
+    return (1);
+  }
+
+  fprintf(fp, "4 R I %s {\n", prodname);
+
+  aix_fileset(fp, prodname, dist, NULL);
+  for (i = 0; i < dist->num_subpackages; i ++)
+    aix_fileset(fp, prodname, dist, dist->subpackages[i]);
+
+  fputs("}\n", fp);
+
+  fclose(fp);
+
+ /*
+  * Write the root partition liblpp.a file...
+  */
+
+  write_liblpp(prodname, directory, dist, 1, NULL);
+  for (i = 0; i < dist->num_subpackages; i ++)
+    write_liblpp(prodname, directory, dist, 1, dist->subpackages[i]);
+
+ /*
+  * Write the usr partition liblpp.a file...
+  */
+
+  write_liblpp(prodname, directory, dist, 0, NULL);
+  for (i = 0; i < dist->num_subpackages; i ++)
+    write_liblpp(prodname, directory, dist, 0, dist->subpackages[i]);
+
+ /*
+  * Copy the files over...
+  */
+
+  if (Verbosity)
+    puts("Copying temporary distribution files...");
+
+  for (i = dist->num_files, file = dist->files; i > 0; i --, file ++)
+  {
+   /*
+    * Find the username and groupname IDs...
+    */
+
+    pwd = getpwnam(file->user);
+    grp = getgrnam(file->group);
+
+    endpwent();
+    endgrent();
+
+   /*
+    * Copy the file or make the directory or make the symlink as needed...
+    */
+
+    switch (tolower(file->type))
+    {
+      case 'c' :
+      case 'f' :
+          if (!strncmp(file->dst, "/export/", 8) ||
+	      !strncmp(file->dst, "/opt/", 5) ||
+	      !strncmp(file->dst, "/usr/", 5))
+            snprintf(filename, sizeof(filename), "%s/%s%s", directory, prodname,
+	             file->dst);
+	  else
+            snprintf(filename, sizeof(filename), "%s/%s/usr/lpp/%s/inst_root%s",
+	             directory, prodname, prodname, file->dst);
+
+	  if (Verbosity > 1)
+	    printf("%s -> %s...\n", file->src, filename);
+
+	  if (copy_file(filename, file->src, file->mode, pwd ? pwd->pw_uid : 0,
+			grp ? grp->gr_gid : 0))
+	    return (1);
+          break;
+      case 'i' :
+          for (runlevels = get_runlevels(file, "2");
+	       isdigit(*runlevels & 255);
+	       runlevels ++)
+	  {
+            snprintf(filename, sizeof(filename),
+	             "%s/%s/usr/lpp/%s/inst_root/etc/rc.d/rc%c.d/S%02d%s",
+	             directory, prodname, prodname, *runlevels,
+		     get_start(file, 99), file->dst);
+
+	    if (Verbosity > 1)
+	      printf("%s -> %s...\n", file->src, filename);
+
+	    if (copy_file(filename, file->src, file->mode,
+	                  pwd ? pwd->pw_uid : 0, grp ? grp->gr_gid : 0))
+	      return (1);
+
+            snprintf(filename, sizeof(filename),
+	             "%s/%s/usr/lpp/%s/inst_root/etc/rc.d/rc%c.d/K%02d%s",
+	             directory, prodname, prodname, *runlevels,
+		     get_stop(file, 0), file->dst);
+
+	    if (Verbosity > 1)
+	      printf("%s -> %s...\n", file->src, filename);
+
+	    if (copy_file(filename, file->src, file->mode,
+	                  pwd ? pwd->pw_uid : 0, grp ? grp->gr_gid : 0))
+	      return (1);
+	  }
+          break;
+      case 'd' :
+          if (!strcmp(file->dst, "/export") ||
+	      !strncmp(file->dst, "/export/", 8) ||
+	      !strcmp(file->dst, "/opt") ||
+	      !strncmp(file->dst, "/opt/", 5) ||
+	      !strcmp(file->dst, "/usr") ||
+	      !strncmp(file->dst, "/usr/", 5))
+            snprintf(filename, sizeof(filename), "%s/%s%s", directory, prodname,
+	             file->dst);
+	  else
+            snprintf(filename, sizeof(filename), "%s/%s/usr/lpp/%s/inst_root%s",
+	             directory, prodname, prodname, file->dst);
+
+	  if (Verbosity > 1)
+	    printf("Directory %s...\n", filename);
+
+          make_directory(filename, file->mode, pwd ? pwd->pw_uid : 0,
+			 grp ? grp->gr_gid : 0);
+          break;
+      case 'l' :
+          if (!strncmp(file->dst, "/export/", 8) ||
+	      !strncmp(file->dst, "/opt/", 5) ||
+	      !strncmp(file->dst, "/usr/", 5))
+            snprintf(filename, sizeof(filename), "%s/%s%s", directory, prodname,
+	             file->dst);
+	  else
+            snprintf(filename, sizeof(filename), "%s/%s/usr/lpp/%s/inst_root%s",
+	             directory, prodname, prodname, file->dst);
+
+	  if (Verbosity > 1)
+	    printf("%s -> %s...\n", file->src, filename);
+
+          make_link(filename, file->src);
+          break;
+    }
+  }
+
+ /*
+  * Build the distribution from the spec file...
+  */
+
+  if (Verbosity)
+    puts("Building AIX binary distribution...");
+
+  snprintf(filename, sizeof(filename), "%s/%s", directory, prodname);
+
+  if (run_command(filename,
+		  "sh -c \'find . -print | backup -i -f ../%s.bff -q %s\'",
+                  prodname, Verbosity ? "-v" : ""))
+    return (1);
+
+ /*
+  * Remove temporary files...
+  */
+
+  if (!KeepFiles)
+  {
+    if (Verbosity)
+      puts("Removing temporary distribution files...");
+
+    snprintf(filename, sizeof(filename), "%s/%s", directory, prodname);
+    unlink_directory(filename);
+
+    for (i = 0; i < (sizeof(files) / sizeof(files[0])); i ++)
+    {
+      snprintf(filename, sizeof(filename), "%s/%s.%s", directory, prodname,
+               files[i]);
+      unlink(filename);
+    }
+
+    snprintf(filename, sizeof(filename), "%s/lpp.README", directory);
+    unlink(filename);
+  }
+
+  return (0);
+}
+
+
+/*
+ * 'aix_addfile()' - Add a file to the AIX directory list...
+ */
+
+static int				/* O  - New number dirs */
+aix_addfile(int        type,		/* I  - Filetype */
+            const char *src,		/* I  - Source path */
+            const char *dst,		/* I  - Destination path */
+	    int        num_dirs,	/* I  - Number of directories */
+            aixdir_t   **dirs)		/* IO - Directories */
+{
+  int		i, j;			/* Looping vars */
+  int		blocks;			/* Blocks to add... */
+  struct stat	fileinfo;		/* File information */
+  aixdir_t	*temp;			/* Temporary pointer */
+  char		dstpath[1024],		/* Destination path */
+		*dstptr;		/* Pointer into destination */
+
+
+ /*
+  * Determine the destination path and block size...
+  */
+
+  strlcpy(dstpath, dst, sizeof(dstpath));
+
+  if (type == 'd')
+  {
+    blocks = 1;
+    dstptr = dstpath + strlen(dstpath) - 1;
+  }
+  else
+  {
+    dstptr = strrchr(dstpath, '/');
+
+    if (type == 'l')
+      blocks = 1;
+    else if (!stat(src, &fileinfo))
+      blocks = (int)((fileinfo.st_size + 511) / 512);
+    else
+      blocks = 0;
+  }
+
+  if (dstptr && *dstptr == '/' && dstptr > dstpath)
+    *dstptr = '\0';
+
+ /*
+  * Now see if the destination path is in the array...
+  */
+
+  temp = *dirs;
+
+  for (i = 0; i < num_dirs; i ++)
+    if ((j = strcmp(temp[i].dst, dstpath)) == 0)
+    {
+      temp[i].blocks += blocks;
+      return (num_dirs);
+    }
+    else if (j > 0)
+      break;
+
+ /*
+  * Not in the list; allocate a new one...
+  */
+
+  if (num_dirs == 0)
+    temp = malloc(sizeof(aixdir_t));
+  else
+    temp = realloc(*dirs, (num_dirs + 1) * sizeof(aixdir_t));
+
+  if (!temp)
+    return (num_dirs);
+
+  *dirs = temp;
+  temp  += i;
+
+  if (i < num_dirs)
+    memmove(temp + 1, temp, (num_dirs - i) * sizeof(aixdir_t));
+
+  strlcpy(temp->dst, dstpath, sizeof(temp->dst));
+  temp->blocks = blocks;
+
+  return (num_dirs + 1);
+}
+
+
+/*
+ * 'aix_fileset()' - Write a subpackage description...
+ */
+
+static void
+aix_fileset(FILE       *fp,		/* I - File to write to */
+            const char *prodname,	/* I - Product name */
+            dist_t     *dist,		/* I - Distribution */
+	    const char *subpackage)	/* I - Subpackage */
+{
+  int			i;		/* Looping var */
+  depend_t		*d;		/* Current dependency */
+  file_t		*file;		/* Current distribution file */
+  int			num_dirs;	/* Number of directories */
+  aixdir_t		*dirs;		/* Directories */
+
+
+ /*
+  * Start fileset definition...
+  */
+
+  if (subpackage)
+    fprintf(fp, "%s.%s", prodname, subpackage);
+  else
+    fprintf(fp, "%s", prodname);
+
+  fprintf(fp, " %s 01 N B x ", aix_version(dist->version));
+
+  if (subpackage)
+  {
+    for (i = 0; i < dist->num_descriptions; i ++)
+    {
+      if (dist->descriptions[i].subpackage == subpackage)
+      {
+	fprintf(fp, "%s\n", dist->descriptions[i].description);
+	break;
+      }
+    }
+  }
+  else
+    fprintf(fp, "%s\n", dist->product);
+
+
+ /*
+  * Dependencies...
+  */
+
+  fputs("[\n", fp);
+  for (i = dist->num_depends, d = dist->depends; i > 0; i --, d ++)
+    if (d->type == DEPEND_REQUIRES && d->subpackage == subpackage &&
+        strcmp(d->product, "_self"))
+      fprintf(fp, "*prereq %s %s\n", d->product, aix_version(d->version[0]));
+
+ /*
+  * Installation sizes...
+  */
+
+  fputs("%\n", fp);
+
+  num_dirs = 0;
+  dirs     = NULL;
+
+  for (i = dist->num_files, file = dist->files; i > 0; i --, file ++)
+    if (file->subpackage == subpackage)
+      num_dirs = aix_addfile(tolower(file->type), file->src, file->dst,
+                             num_dirs, &dirs);
+
+  for (i = 0; i < num_dirs; i ++)
+    fprintf(fp, "%s %d\n", dirs[i].dst, dirs[i].blocks);
+
+  if (num_dirs > 0)
+    free(dirs);
+
+ /*
+  * This package supercedes which others?
+  */
+
+  fputs("%\n", fp);
+  for (i = dist->num_depends, d = dist->depends; i > 0; i --, d ++)
+    if (d->type == DEPEND_REPLACES && d->subpackage == subpackage &&
+        strcmp(d->product, "_self"))
+      fprintf(fp, "%s %s", d->product, aix_version(d->version[0]));
+
+ /*
+  * Fix information is only used for updates (patches)...
+  */
+
+  fputs("%\n", fp);
+  fputs("]\n", fp);
+}
+
+
+/*
+ * 'aix_version()' - Generate an AIX version number.
+ */
+
+static char *				/* O - AIX version number */
+aix_version(const char *version)	/* I - EPM version number */
+{
+  int		verparts[4];		/* Version number parts */
+  static char	aix[255];		/* AIX version number string */
+
+
+ /*
+  * AIX requires a four-part version number (M.m.p.r)...
+  */
+
+  memset(verparts, 0, sizeof(verparts));
+  sscanf(version, "%d.%d.%d.%d", verparts + 0, verparts + 1,
+         verparts + 2, verparts + 3);
+  snprintf(aix, sizeof(aix), "%d.%d.%d.%d", verparts[0], verparts[1],
+          verparts[2], verparts[3]);
+
+  return (aix);
+}
+
+
+/*
+ * 'write_liblpp()' - Create the liblpp.a file for the root or /usr parts.
+ */
+
+static int				/* O - 0 = success, 1 = fail */
+write_liblpp(const char     *prodname,	/* I - Product short name */
+             const char     *directory,	/* I - Directory for distribution files */
+             dist_t         *dist,	/* I - Distribution information */
+             int            root,	/* I - Root partition? */
+	     const char     *subpackage)/* I - Subpackage */
+{
+  int			i;		/* Looping var */
+  FILE			*fp;		/* Control file */
+  char			filename[1024],	/* Destination filename */
+			prodfull[1024];	/* Full product name */
+  struct stat		fileinfo;	/* File information */
+  command_t		*c;		/* Current command */
+  file_t		*file;		/* Current distribution file */
+  int			configcount;	/* Number of config files */
+  int 			shared_file;	/* Shared file? */
+  const char		*runlevels;	/* Run levels */
+
+
+ /*
+  * Progress info...
+  */
+
+  if (subpackage)
+    snprintf(prodfull, sizeof(prodfull), "%s.%s", prodname, subpackage);
+  else
+    strlcpy(prodfull, prodname, sizeof(prodfull));
+
+  if (Verbosity)
+    printf("Updating %s partition liblpp.a file for %s...\n",
+           root ? "root" : "shared", prodfull);
+
+ /*
+  * Write the product.al file for installp...
+  */
+
+  if (Verbosity > 1)
+    puts("    Creating .al file...");
+
+  snprintf(filename, sizeof(filename), "%s/%s.al", directory, prodfull);
+
+  if ((fp = fopen(filename, "w")) == NULL)
+  {
+    fprintf(stderr, "epm: Unable to create .al file \"%s\": %s\n", filename, strerror(errno));
+    return (1);
+  }
+
+  for (i = dist->num_files, file = dist->files; i > 0; i --, file ++)
+    if (file->subpackage == subpackage)
+      switch (tolower(file->type))
+      {
+	case 'i' :
+            for (runlevels = get_runlevels(file, "2");
+		 isdigit(*runlevels & 255);
+		 runlevels ++)
+            {
+	      if (root)
+	        putc('.', fp);
+	      else
+        	qprintf(fp, "./usr/lpp/%s/inst_root", prodfull);
+
+              if (*runlevels == '0')
+        	qprintf(fp, "/etc/rc.d/rc0.d/K%02d%s\n",
+		        get_stop(file, 0), file->dst);
+	      else
+        	qprintf(fp, "/etc/rc.d/rc%c.d/S%02d%s\n",
+	        	*runlevels, get_start(file, 99), file->dst);
+            }
+	    break;
+
+	default :
+            shared_file = !(strcmp(file->dst, "/usr") &&
+                            strncmp(file->dst, "/usr/", 5) &&
+                            strcmp(file->dst, "/opt") &&
+                            strncmp(file->dst, "/opt/", 5));
+
+           /*
+	    * Put file in root or share .al file as appropriate
+            */
+
+            if ((shared_file && !root) || (!shared_file && root))
+              qprintf(fp, ".%s\n", file->dst);
+
+           /*
+	    * Put any root file in the share .al so it will be extracted
+	    * to /usr/lpp/<prodfull>/inst_root directory.  I have no
+	    * idea if this is really the way to do it but it seems to
+	    * work...
+	    */
+
+            if (!shared_file && !root)
+              qprintf(fp, "./usr/lpp/%s/inst_root%s\n", prodfull, file->dst);
+	    break;
+      }
+
+  fclose(fp);
+
+ /*
+  * Write the product.cfgfiles file for installp...
+  */
+
+  if (Verbosity > 1)
+    puts("    Creating .cfgfiles file...");
+
+  snprintf(filename, sizeof(filename), "%s/%s.cfgfiles", directory, prodfull);
+
+  if ((fp = fopen(filename, "w")) == NULL)
+  {
+    fprintf(stderr, "epm: Unable to create .cfgfiles file \"%s\": %s\n", filename, strerror(errno));
+    return (1);
+  }
+
+  configcount = 0;
+
+  for (i = dist->num_files, file = dist->files; i > 0; i --, file ++)
+    if (tolower(file->type) == 'c' && file->subpackage == subpackage &&
+        (strcmp(file->dst, "/usr") ||
+	 strncmp(file->dst, "/usr/", 5) ||
+	 strcmp(file->dst, "/opt") ||
+	 strncmp(file->dst, "/opt/", 5)) == root)
+    {
+      qprintf(fp, ".%s hold_new\n", file->dst);
+      configcount ++;
+    }
+
+  fclose(fp);
+
+ /*
+  * Write the product.copyright file for installp...
+  */
+
+  if (Verbosity > 1)
+    puts("    Creating .copyright file...");
+
+  snprintf(filename, sizeof(filename), "%s/%s.copyright", directory, prodfull);
+
+  if ((fp = fopen(filename, "w")) == NULL)
+  {
+    fprintf(stderr, "epm: Unable to create .copyright file \"%s\": %s\n", filename, strerror(errno));
+    return (1);
+  }
+
+  fprintf(fp, "%s, %s\n%s\n%s\n", dist->product, aix_version(dist->version),
+          dist->vendor, dist->copyright);
+
+  fclose(fp);
+
+  if (root)
+  {
+   /*
+    * Write the product.pre_i file for installp...
+    */
+
+    if (Verbosity > 1)
+      puts("    Creating .pre_i file...");
+
+    snprintf(filename, sizeof(filename), "%s/%s.pre_i", directory, prodfull);
+
+    if ((fp = fopen(filename, "w")) == NULL)
+    {
+      fprintf(stderr, "epm: Unable to create .pre_i file \"%s\": %s\n", filename, strerror(errno));
+      return (1);
+    }
+
+    fchmod(fileno(fp), 0755);
+
+    fputs("#!/bin/sh\n", fp);
+    fputs("# " EPM_VERSION "\n", fp);
+
+    for (c = dist->commands, i = dist->num_commands; i > 0; i --, c ++)
+      if (c->type == COMMAND_PRE_INSTALL && c->subpackage == subpackage)
+	fprintf(fp, "%s\n", c->command);
+
+    fclose(fp);
+
+   /*
+    * Write the product.post_i file for installp...
+    */
+
+    if (Verbosity > 1)
+      puts("    Creating .post_i file...");
+
+    snprintf(filename, sizeof(filename), "%s/%s.post_i", directory, prodfull);
+
+    if ((fp = fopen(filename, "w")) == NULL)
+    {
+      fprintf(stderr, "epm: Unable to create .post_i file \"%s\": %s\n", filename, strerror(errno));
+      return (1);
+    }
+
+    fchmod(fileno(fp), 0755);
+
+    fputs("#!/bin/sh\n", fp);
+    fputs("# " EPM_VERSION "\n", fp);
+
+    for (c = dist->commands, i = dist->num_commands; i > 0; i --, c ++)
+      if (c->type == COMMAND_POST_INSTALL && c->subpackage == subpackage)
+	fprintf(fp, "%s\n", c->command);
+
+    fclose(fp);
+
+   /*
+    * Write the product.unpre_i file for installp...
+    */
+
+    if (Verbosity > 1)
+      puts("	Creating .unpre_i file...");
+
+    snprintf(filename, sizeof(filename), "%s/%s.unpre_i", directory, prodfull);
+
+    if ((fp = fopen(filename, "w")) == NULL)
+    {
+      fprintf(stderr, "epm: Unable to create .unpre_i file \"%s\": %s\n", filename, strerror(errno));
+      return (1);
+    }
+
+    fchmod(fileno(fp), 0755);
+
+    fputs("#!/bin/sh\n", fp);
+    fputs("# " EPM_VERSION "\n", fp);
+
+    for (c = dist->commands, i = dist->num_commands; i > 0; i --, c ++)
+      if (c->type == COMMAND_PRE_REMOVE && c->subpackage == subpackage)
+	fprintf(fp, "%s\n", c->command);
+
+    fclose(fp);
+
+   /*
+    * Write the product.unpost_i file for installp...
+    */
+
+    if (Verbosity > 1)
+      puts("    Creating .unpost_i file...");
+
+    snprintf(filename, sizeof(filename), "%s/%s.unpost_i", directory, prodfull);
+
+    if ((fp = fopen(filename, "w")) == NULL)
+    {
+      fprintf(stderr, "epm: Unable to create .unpost_i file \"%s\": %s\n", filename, strerror(errno));
+      return (1);
+    }
+
+    fchmod(fileno(fp), 0755);
+
+    fputs("#!/bin/sh\n", fp);
+    fputs("# " EPM_VERSION "\n", fp);
+
+    for (c = dist->commands, i = dist->num_commands; i > 0; i --, c ++)
+     if (c->type == COMMAND_POST_REMOVE && c->subpackage == subpackage)
+	fprintf(fp, "%s\n", c->command);
+
+    fclose(fp);
+  }
+
+ /*
+  * Write the product.inventory file for installp...
+  */
+
+  if (Verbosity > 1)
+    puts("    Creating .inventory file...");
+
+  snprintf(filename, sizeof(filename), "%s/%s.inventory", directory, prodfull);
+
+  if ((fp = fopen(filename, "w")) == NULL)
+  {
+    fprintf(stderr, "epm: Unable to create .inventory file \"%s\": %s\n", filename, strerror(errno));
+    return (1);
+  }
+
+  for (i = dist->num_files, file = dist->files; i > 0; i --, file ++)
+  {
+    if (file->subpackage != subpackage)
+      continue;
+
+    if (root)
+    {
+      if (!strcmp(file->dst, "/usr") ||
+	  !strncmp(file->dst, "/usr/", 5) ||
+	  !strcmp(file->dst, "/opt") ||
+	  !strncmp(file->dst, "/opt/", 5))
+        continue;
+    }
+    else
+    {
+      if (tolower(file->type) == 'c' ||
+          (strcmp(file->dst, "/usr") &&
+	   strncmp(file->dst, "/usr/", 5) &&
+	   strcmp(file->dst, "/opt") &&
+	   strncmp(file->dst, "/opt/", 5)))
+	continue;
+    }
+
+    switch (tolower(file->type))
+    {
+      case 'i' :
+          for (runlevels = get_runlevels(file, "2");
+	       isdigit(*runlevels & 255);
+	       runlevels ++)
+          {
+	    if (*runlevels == '0')
+	      qprintf(fp, "/etc/rc.d/rc0.d/K%02d%s:\n",
+	              get_stop(file, 0), file->dst);
+            else
+	      qprintf(fp, "/etc/rc.d/rc%c.d/S%02d%s:\n",
+	              *runlevels, get_start(file, 99), file->dst);
+
+	    fprintf(fp, "    class=apply,inventory,%s\n", prodfull);
+
+            fputs("    type=FILE\n", fp);
+            if (!stat(file->src, &fileinfo))
+	      fprintf(fp, "    size=%d\n", (int)fileinfo.st_size);
+
+	    fprintf(fp, "    owner=%s\n", file->user);
+	    fprintf(fp, "    group=%s\n", file->group);
+	    fprintf(fp, "    mode=%04o\n", (unsigned)file->mode);
+	    fputs("\n", fp);
+	  }
+	  break;
+      default :
+          qprintf(fp, "%s:\n", file->dst);
+	  fprintf(fp, "    class=apply,inventory,%s\n", prodfull);
+
+	  switch (tolower(file->type))
+	  {
+	    case 'd' :
+        	fputs("    type=DIRECTORY\n", fp);
+        	break;
+	    case 'l' :
+        	fputs("    type=SYMLINK\n", fp);
+		qprintf(fp, "    target=%s\n", file->src);
+        	break;
+	    case 'c' :
+        	fputs("    type=FILE\n", fp);
+        	fputs("    size=VOLATILE\n", fp);
+		break;
+	    default :
+        	fputs("    type=FILE\n", fp);
+        	if (!stat(file->src, &fileinfo))
+		  fprintf(fp, "    size=%ld\n", (long)fileinfo.st_size);
+		break;
+	  }
+
+	  fprintf(fp, "    owner=%s\n", file->user);
+	  fprintf(fp, "    group=%s\n", file->group);
+	  fprintf(fp, "    mode=%04o\n", (unsigned)file->mode);
+	  fputs("\n", fp);
+	  break;
+    }
+  }
+
+  fclose(fp);
+
+ /*
+  * Write the lpp.README file...
+  */
+
+  snprintf(filename, sizeof(filename), "%s/lpp.README", directory);
+
+  if (dist->license[0])
+    copy_file(filename, dist->license, 0644, 0, 0);
+  else if (dist->readme[0])
+    copy_file(filename, dist->readme, 0644, 0, 0);
+  else if ((fp = fopen(filename, "w")) != NULL)
+    fclose(fp);
+  else
+  {
+    fprintf(stderr, "epm: Unable to create .README file \"%s\": %s\n", filename, strerror(errno));
+    return (1);
+  }
+
+ /*
+  * Create the liblpp.a file...
+  */
+
+  if (Verbosity > 1)
+    puts("    Creating liblpp.a archive...");
+
+  if (root)
+  {
+    snprintf(filename, sizeof(filename), "%s/%s/usr/lpp/%s/inst_root",
+             directory, prodname, prodname);
+    make_directory(filename, 0755, 0, 0);
+
+    snprintf(filename, sizeof(filename), "%s/usr/lpp/%s/inst_root/liblpp.a",
+             prodname, prodname);
+  }
+  else
+  {
+    snprintf(filename, sizeof(filename), "%s/%s/usr/lpp/%s",
+             directory, prodname, prodname);
+    make_directory(filename, 0755, 0, 0);
+
+    snprintf(filename, sizeof(filename), "%s/usr/lpp/%s/liblpp.a",
+             prodname, prodname);
+  }
+
+  if (!subpackage)
+    if (run_command(directory, "ar rc %s lpp.README", filename))
+      return (1);
+
+  for (i = 0; i < (sizeof(files) / sizeof(files[0])); i ++)
+  {
+    if (i >= 4 && !root)
+      break;
+
+    if (i == 1 && !configcount)
+      continue;
+
+    if (run_command(directory, "ar rc %s %s.%s",
+                    filename, prodfull, files[i]))
+      return (1);
+  }
+
+  return (0);
+}
diff --git a/tmp/epm/bsd.c b/./epm/bsd.c
index 8086146..9e7d957 100644
--- a/tmp/epm/bsd.c
+++ b/./epm/bsd.c
@@ -26,6 +26,18 @@
  * Local functions...
  */
 
+#ifdef __FOR_AOO__
+static void cr2semicolon(char *command)
+{
+  int		len, i;
+
+  len = strlen(command);
+  for (i = 0; i < len; i++)
+    if (*(command+i)=='\n')
+      *(command+i)=';';
+}
+#endif
+
 static int	make_subpackage(const char *prodname, const char *directory,
 		                const char *platname, dist_t *dist,
 			        const char *subpackage);
@@ -197,12 +209,24 @@ make_subpackage(
     if (d->subpackage != subpackage)
       continue;
 
+#ifdef __FOR_AOO__
+#ifdef __FreeBSD__
+    if (d->type == DEPEND_REQUIRES) {
+      if (dist->relnumber) {
+        fprintf(fp, "@pkgdep %s-%s-%d-%s", d->product, dist->version, dist->relnumber, platname);
+      } else {
+        fprintf(fp, "@pkgdep %s-%s-%s", d->product, dist->version, platname);
+      }
+    } else
+#endif /* __FreeBSD__ */
+#else
     if (d->type == DEPEND_REQUIRES)
 #ifdef __OpenBSD__
       fprintf(fp, "@depend %s", d->product);
 #else
       fprintf(fp, "@pkgdep %s", d->product);
 #endif /* __OpenBSD__ */
+#endif /* __FOR_AOO__ */
     else
 #ifdef __FreeBSD__
      /*
@@ -229,9 +253,15 @@ make_subpackage(
 	          "         by the BSD packager.\n", stderr);
             break;
 	case COMMAND_POST_INSTALL :
+#ifdef __FOR_AOO__
+	    cr2semicolon(c->command);
+#endif /* __FOR_AOO__ */
             fprintf(fp, "@exec %s\n", c->command);
 	    break;
 	case COMMAND_PRE_REMOVE :
+#ifdef __FOR_AOO__
+	    cr2semicolon(c->command);
+#endif /* __FOR_AOO__ */
             fprintf(fp, "@unexec %s\n", c->command);
 	    break;
 	case COMMAND_POST_REMOVE :
diff --git a/tmp/epm/config.h.in b/./epm/config.h.in
index 765b587..7870c1a 100644
--- a/tmp/epm/config.h.in
+++ b/./epm/config.h.in
@@ -50,6 +50,7 @@
  */
 
 #define EPM_RPMBUILD	"rpm"
+#define EPM_RPMBUILD_NEW "rpmbuild"
 
 
 /*
diff --git a/tmp/epm/configure b/./epm/configure
index 5fabb92..27a3674 100755
--- a/tmp/epm/configure
+++ b/./epm/configure
@@ -1,8 +1,8 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.69 for EPM 4.5.
+# Generated by GNU Autoconf 2.69 for EPM 4.5.0-jj.
 #
-# Report bugs to <https://github.com/michaelrsweet/epm/issues>.
+# Report bugs to <https://github.com/jimjag/epm/issues>.
 #
 #
 # Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.
@@ -267,8 +267,8 @@ fi
     $as_echo "$0: be upgraded to zsh 4.3.4 or later."
   else
     $as_echo "$0: Please tell bug-autoconf@gnu.org and
-$0: https://github.com/michaelrsweet/epm/issues about your
-$0: system, including any error possibly output before this
+$0: https://github.com/jimjag/epm/issues about your system,
+$0: including any error possibly output before this
 $0: message. Then install a modern shell, or manually run
 $0: the script under such a shell if you do have one."
   fi
@@ -580,10 +580,10 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='EPM'
 PACKAGE_TARNAME='epm'
-PACKAGE_VERSION='4.5'
-PACKAGE_STRING='EPM 4.5'
-PACKAGE_BUGREPORT='https://github.com/michaelrsweet/epm/issues'
-PACKAGE_URL='https://www.msweet.org/epm'
+PACKAGE_VERSION='4.5.0-jj'
+PACKAGE_STRING='EPM 4.5.0-jj'
+PACKAGE_BUGREPORT='https://github.com/jimjag/epm/issues'
+PACKAGE_URL='https://github.com/jimjag/epm'
 
 # Factoring default headers for most tests.
 ac_includes_default="\
@@ -642,6 +642,8 @@ STRIP
 RPMBUILD
 RPM
 RM
+GROFF
+NROFF
 MKDIR
 INSTALL_DATA
 INSTALL_SCRIPT
@@ -652,6 +654,9 @@ CP
 CODE_SIGN
 CHMOD
 AR
+INSTALL_DATA
+INSTALL_SCRIPT
+INSTALL_PROGRAM
 RANLIB
 ac_ct_CXX
 CXXFLAGS
@@ -720,6 +725,8 @@ with_archflags
 with_optim
 enable_debug
 enable_gui
+enable_fltk
+enable_aoo
 with_docdir
 with_softwaredir
 '
@@ -1275,7 +1282,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures EPM 4.5 to adapt to many kinds of systems.
+\`configure' configures EPM 4.5.0-jj to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1340,7 +1347,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of EPM 4.5:";;
+     short | recursive ) echo "Configuration of EPM 4.5.0-jj:";;
    esac
   cat <<\_ACEOF
 
@@ -1350,6 +1357,8 @@ Optional Features:
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
   --enable-debug          turn on debugging [default=no]
   --enable-gui            turn on GUI utilities [default=auto]
+  --enable-fltk          enable fltk [default=auto]
+  --enable-aoo           enable AOO modifications [default=no]
 
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
@@ -1376,8 +1385,8 @@ Some influential environment variables:
 Use these variables to override the choices made by `configure' or to help
 it to find libraries and programs with nonstandard names/locations.
 
-Report bugs to <https://github.com/michaelrsweet/epm/issues>.
-EPM home page: <https://www.msweet.org/epm>.
+Report bugs to <https://github.com/jimjag/epm/issues>.
+EPM home page: <https://github.com/jimjag/epm>.
 _ACEOF
 ac_status=$?
 fi
@@ -1440,7 +1449,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-EPM configure 4.5
+EPM configure 4.5.0-jj
 generated by GNU Autoconf 2.69
 
 Copyright (C) 2012 Free Software Foundation, Inc.
@@ -1756,9 +1765,9 @@ $as_echo "$as_me: WARNING: $2: see the Autoconf documentation" >&2;}
 $as_echo "$as_me: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&2;}
     { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
 $as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
-( $as_echo "## ---------------------------------------------------------- ##
-## Report this to https://github.com/michaelrsweet/epm/issues ##
-## ---------------------------------------------------------- ##"
+( $as_echo "## --------------------------------------------------- ##
+## Report this to https://github.com/jimjag/epm/issues ##
+## --------------------------------------------------- ##"
      ) | sed "s/^/$as_me: WARNING:     /" >&2
     ;;
 esac
@@ -1847,7 +1856,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by EPM $as_me 4.5, which was
+It was created by EPM $as_me 4.5.0-jj, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   $ $0 $@
@@ -2198,8 +2207,9 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 ac_config_headers="$ac_config_headers config.h"
 
 
-VERSION="4.5"
-VERNUMBER=450
+
+VERSION="4.5.0-jj"
+VERNUMBER=450jj
 
 
 cat >>confdefs.h <<_ACEOF
@@ -2308,8 +2318,13 @@ case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
 
 
 
+uname=`uname`
+uversion=`uname -r | sed -e '1,$s/[^0-9]//g'`
 host_os_name=`echo $host_os | sed -e '1,$s/[0-9.]*$//g'`
 
+if test "$uname" = "IRIX64"; then
+    uname="IRIX"
+fi
 
 
 CFLAGS="${CFLAGS:=}"
@@ -2353,6 +2368,18 @@ if test "${enable_gui+set}" = set; then :
 fi
 
 
+# Check whether --enable-fltk was given.
+if test "${enable_fltk+set}" = set; then :
+  enableval=$enable_fltk;
+fi
+
+
+# Check whether --enable-aoo was given.
+if test "${enable_aoo+set}" = set; then :
+  enableval=$enable_aoo;
+fi
+
+
 
 # Check whether --with-docdir was given.
 if test "${with_docdir+set}" = set; then :
@@ -3319,6 +3346,99 @@ else
   RANLIB="$ac_cv_prog_RANLIB"
 fi
 
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+# Reject install programs that cannot install multiple files.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a BSD-compatible install" >&5
+$as_echo_n "checking for a BSD-compatible install... " >&6; }
+if test -z "$INSTALL"; then
+if ${ac_cv_path_install+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in #((
+  ./ | .// | /[cC]/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:[\\/]os2[\\/]install[\\/]* | ?:[\\/]OS2[\\/]INSTALL[\\/]* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if as_fn_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    rm -rf conftest.one conftest.two conftest.dir
+	    echo one > conftest.one
+	    echo two > conftest.two
+	    mkdir conftest.dir
+	    if "$as_dir/$ac_prog$ac_exec_ext" -c conftest.one conftest.two "`pwd`/conftest.dir" &&
+	      test -s conftest.one && test -s conftest.two &&
+	      test -s conftest.dir/conftest.one &&
+	      test -s conftest.dir/conftest.two
+	    then
+	      ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	      break 3
+	    fi
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+
+  done
+IFS=$as_save_IFS
+
+rm -rf conftest.one conftest.two conftest.dir
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    INSTALL=$ac_install_sh
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $INSTALL" >&5
+$as_echo "$INSTALL" >&6; }
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
 # Extract the first word of "ar", so it can be a program name with args.
 set dummy ar; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
@@ -3709,6 +3829,93 @@ $as_echo "no" >&6; }
 fi
 
 
+# Extract the first word of "nroff", so it can be a program name with args.
+set dummy nroff; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_NROFF+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $NROFF in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_NROFF="$NROFF" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_NROFF="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+NROFF=$ac_cv_path_NROFF
+if test -n "$NROFF"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $NROFF" >&5
+$as_echo "$NROFF" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+if test x$NROFF = x; then
+	# Extract the first word of "groff", so it can be a program name with args.
+set dummy groff; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_GROFF+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $GROFF in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_GROFF="$GROFF" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_GROFF="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  ;;
+esac
+fi
+GROFF=$ac_cv_path_GROFF
+if test -n "$GROFF"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $GROFF" >&5
+$as_echo "$GROFF" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+	if test x$GROFF = x; then
+        	NROFF="echo"
+	else
+        	NROFF="$GROFF -T ascii"
+	fi
+fi
 # Extract the first word of "rm", so it can be a program name with args.
 set dummy rm; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
@@ -4383,6 +4590,12 @@ if test $ac_cv_c_char_unsigned = yes && test "$GCC" != yes; then
 fi
 
 
+if test "$uname" = "IRIX"; then
+	if test `uname -r` = 6.5; then
+		STRIP="$STRIP -f -s -k -l -h"
+	fi
+fi
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
 $as_echo_n "checking for ANSI C header files... " >&6; }
 if ${ac_cv_header_stdc+:} false; then :
@@ -4701,7 +4914,11 @@ _ACEOF
 fi
 done
 
-for ac_func in snprintf vsnprintf
+if test "$uname" = "HP-UX" -a "$uversion" = "1020"; then
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Forcing snprintf emulation for HP-UX." >&5
+$as_echo "$as_me: WARNING: Forcing snprintf emulation for HP-UX." >&2;}
+else
+	for ac_func in snprintf vsnprintf
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
@@ -4713,6 +4930,7 @@ _ACEOF
 fi
 done
 
+fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing gethostname" >&5
 $as_echo_n "checking for library containing gethostname... " >&6; }
 if ${ac_cv_search_gethostname+:} false; then :
@@ -4770,7 +4988,18 @@ if test "$ac_res" != no; then :
 fi
 
 
-if test "x$enable_gui" != xno; then
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking Checking if building for Apache OpenOffice" >&5
+$as_echo_n "checking Checking if building for Apache OpenOffice... " >&6; }
+if test "x$enable_aoo" = xyes; then
+	CFLAGS="-D__FOR_AOO__ $CFLAGS"
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+if test "x$enable_gui" != xno && test "x$enable_fltk" = xyes; then
 	# Extract the first word of "fltk-config", so it can be a program name with args.
 set dummy fltk-config; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
@@ -4949,6 +5178,79 @@ $as_echo "no" >&6; }
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 	CFLAGS="$OLDCFLAGS"
+
+	# See if we are running HP-UX or Solaris; if so, try the
+	# -fpermissive option...
+	case $uname in
+		SunOS* | HP-UX*)
+			{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if GCC supports -fpermissive" >&5
+$as_echo_n "checking if GCC supports -fpermissive... " >&6; }
+
+			OLDCFLAGS="$CFLAGS"
+			CFLAGS="$CFLAGS -fpermissive"
+			cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  CXXFLAGS="$CXXFLAGS -fpermissive"
+				{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+			CFLAGS="$OLDCFLAGS"
+			;;
+
+		*)
+			;;
+	esac
+else
+	case $uname in
+		AIX*)
+			if test -z "$OPTIM"; then
+				OPTIM="-O2"
+			fi
+			;;
+		HP-UX*)
+			if test -z "$OPTIM"; then
+				OPTIM="+O2"
+			fi
+			OPTIM="$OPTIM +DAportable"
+			;;
+        	IRIX*)
+			if test -z "$OPTIM"; then
+        			OPTIM="-O2"
+			fi
+			if test $uversion -ge 62; then
+				OPTIM="$OPTIM -n32 -mips3"
+				OPTIM="$OPTIM -OPT:Olimit=3000"
+				OPTIM="-fullwarn -woff 1209,1506,1692 $OPTIM"
+			else
+				OPTIM="-fullwarn $OPTIM"
+			fi
+			;;
+		SunOS*)
+			# Solaris
+			if test -z "$OPTIM"; then
+				OPTIM="-xO4"
+			fi
+			;;
+		*)
+			# Running some other operating system...
+			echo "Building EPM with default compiler optimizations.  Set the CFLAGS and CXXFLAGS"
+			echo "environment variable before running configure to override them."
+			;;
+	esac
 fi
 
 case $host_os_name in
@@ -4992,6 +5294,23 @@ elif test "$datadir" = "\${datarootdir}"; then
 	datadir="$datarootdir"
 fi
 
+if test "$mandir" = "\${prefix}/man" -a "$prefix" = "/usr"; then
+	case "$uname" in
+        	*BSD* | Darwin* | Linux*)
+        		# BSD, Darwin (macOS), and Linux
+        		mandir="/usr/share/man"
+        		;;
+        	IRIX*)
+        		# SGI IRIX
+        		mandir="/usr/share/catman/u_man"
+        		;;
+        	*)
+        		# All others
+        		mandir="/usr/man"
+        		;;
+	esac
+fi
+
 if test x$softwaredir = x; then
 	EPM_SOFTWARE="/etc/software"
 else
@@ -5587,7 +5906,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by EPM $as_me 4.5, which was
+This file was extended by EPM $as_me 4.5.0-jj, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -5643,14 +5962,14 @@ $config_files
 Configuration headers:
 $config_headers
 
-Report bugs to <https://github.com/michaelrsweet/epm/issues>.
-EPM home page: <https://www.msweet.org/epm>."
+Report bugs to <https://github.com/jimjag/epm/issues>.
+EPM home page: <https://github.com/jimjag/epm>."
 
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
-EPM config.status 4.5
+EPM config.status 4.5.0-jj
 configured by $0, generated by GNU Autoconf 2.69,
   with options \\"\$ac_cs_config\\"
 
@@ -5762,6 +6081,10 @@ _ASBOX
   $as_echo "$ac_log"
 } >&5
 
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
+  esac
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 _ACEOF
diff --git a/tmp/epm/configure.ac b/./epm/configure.ac
index bf8e416..5c94a44 100644
--- a/tmp/epm/configure.ac
+++ b/./epm/configure.ac
@@ -15,12 +15,13 @@ dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 dnl GNU General Public License for more details.
 dnl
 
-AC_INIT([EPM],[4.5],[https://github.com/michaelrsweet/epm/issues],[epm],[https://www.msweet.org/epm])
+AC_INIT([EPM],[4.5.0-jj],[https://github.com/jimjag/epm/issues],[epm],[https://github.com/jimjag/epm])
 AC_CONFIG_HEADER(config.h)
 
 dnl Version number...
+
 VERSION="AC_PACKAGE_VERSION"
-VERNUMBER=450
+VERNUMBER=450jj
 AC_SUBST(VERSION)
 AC_SUBST(VERNUMBER)
 AC_DEFINE_UNQUOTED(EPM_VERSION, "ESP Package Manager v$VERSION")
@@ -29,8 +30,13 @@ dnl Get the build and host platforms and split the host_os value
 AC_CANONICAL_BUILD
 AC_CANONICAL_HOST
 
+uname=`uname`
+uversion=`uname -r | sed -e '1,$s/[[^0-9]]//g'`
 [host_os_name=`echo $host_os | sed -e '1,$s/[0-9.]*$//g'`]
 
+if test "$uname" = "IRIX64"; then
+    uname="IRIX"
+fi
 
 dnl Clear default debugging options and set normal optimization by
 dnl default unless the user asks for debugging specifically.
@@ -59,6 +65,10 @@ fi)
 
 AC_ARG_ENABLE(gui, [  --enable-gui            turn on GUI utilities [[default=auto]]])
 
+AC_ARG_ENABLE(fltk, [  --enable-fltk          enable fltk [[default=auto]]])
+
+AC_ARG_ENABLE(aoo, [  --enable-aoo           enable AOO modifications [[default=no]]])
+
 AC_ARG_WITH(docdir, [  --with-docdir=/dir      set directory for documentation
                           [[default=${datadir}/doc/epm]]],
 	docdir="$withval",
@@ -75,6 +85,7 @@ dnl Checks for programs...
 AC_PROG_CC(clang cc gcc)
 AC_PROG_CXX(clang++ c++ g++)
 AC_PROG_RANLIB
+AC_PROG_INSTALL
 AC_PATH_PROG(AR,ar)
 AC_PATH_PROG(CHMOD,chmod)
 AC_PATH_PROGS(CODE_SIGN, codesign true)
@@ -90,6 +101,15 @@ if test "$INSTALL" = "$ac_install_sh"; then
         INSTALL="`pwd`/install-sh -c"
 fi
 AC_PATH_PROG(MKDIR,mkdir)
+AC_PATH_PROG(NROFF,nroff)
+if test x$NROFF = x; then
+	AC_PATH_PROG(GROFF,groff)
+	if test x$GROFF = x; then
+        	NROFF="echo"
+	else
+        	NROFF="$GROFF -T ascii"
+	fi
+fi
 AC_PATH_PROG(RM,rm)
 AC_PATH_PROG(RPM,rpm)
 AC_PATH_PROG(RPMBUILD,rpmbuild)
@@ -99,6 +119,12 @@ dnl Architecture checks...
 AC_C_CONST
 AC_C_CHAR_UNSIGNED
 
+if test "$uname" = "IRIX"; then
+	if test `uname -r` = 6.5; then
+		STRIP="$STRIP -f -s -k -l -h"
+	fi
+fi
+
 dnl Checks for header files.
 AC_HEADER_STDC
 AC_HEADER_DIRENT
@@ -110,10 +136,22 @@ AC_CHECK_HEADER(sys/vfs.h,AC_DEFINE(HAVE_SYS_VFS_H))
 
 dnl Checks for string functions.
 AC_CHECK_FUNCS(strcasecmp strdup strlcat strlcpy strncasecmp)
-AC_CHECK_FUNCS(snprintf vsnprintf)
+if test "$uname" = "HP-UX" -a "$uversion" = "1020"; then
+	AC_MSG_WARN(Forcing snprintf emulation for HP-UX.)
+else
+	AC_CHECK_FUNCS(snprintf vsnprintf)
+fi
 AC_SEARCH_LIBS(gethostname, socket)
 
-if test "x$enable_gui" != xno; then
+AC_MSG_CHECKING(Checking if building for Apache OpenOffice)
+if test "x$enable_aoo" = xyes; then
+	CFLAGS="-D__FOR_AOO__ $CFLAGS"
+	AC_MSG_RESULT(yes)
+else
+	AC_MSG_RESULT(no)
+fi
+
+if test "x$enable_gui" != xno && test "x$enable_fltk" = xyes; then
 	AC_PATH_PROG(FLTKCONFIG,fltk-config)
 else
 	FLTKCONFIG=""
@@ -199,6 +237,62 @@ if test -n "$GCC"; then
 		AC_MSG_RESULT(yes),
 		AC_MSG_RESULT(no))
 	CFLAGS="$OLDCFLAGS"
+
+	# See if we are running HP-UX or Solaris; if so, try the
+	# -fpermissive option...
+	case $uname in
+		SunOS* | HP-UX*)
+			AC_MSG_CHECKING(if GCC supports -fpermissive)
+
+			OLDCFLAGS="$CFLAGS"
+			CFLAGS="$CFLAGS -fpermissive"
+			AC_TRY_COMPILE(,,
+				CXXFLAGS="$CXXFLAGS -fpermissive"
+				AC_MSG_RESULT(yes),
+				AC_MSG_RESULT(no))
+			CFLAGS="$OLDCFLAGS"
+			;;
+
+		*)
+			;;
+	esac
+else
+	case $uname in
+		AIX*)
+			if test -z "$OPTIM"; then
+				OPTIM="-O2"
+			fi
+			;;
+		HP-UX*)
+			if test -z "$OPTIM"; then
+				OPTIM="+O2"
+			fi
+			OPTIM="$OPTIM +DAportable"
+			;;
+        	IRIX*)
+			if test -z "$OPTIM"; then
+        			OPTIM="-O2"
+			fi
+			if test $uversion -ge 62; then
+				OPTIM="$OPTIM -n32 -mips3"
+				OPTIM="$OPTIM -OPT:Olimit=3000"
+				OPTIM="-fullwarn -woff 1209,1506,1692 $OPTIM"
+			else
+				OPTIM="-fullwarn $OPTIM"
+			fi
+			;;
+		SunOS*)
+			# Solaris
+			if test -z "$OPTIM"; then
+				OPTIM="-xO4"
+			fi
+			;;
+		*)
+			# Running some other operating system...
+			echo "Building EPM with default compiler optimizations.  Set the CFLAGS and CXXFLAGS"
+			echo "environment variable before running configure to override them."
+			;;
+	esac
 fi
 
 dnl Flags for "ar" command...
@@ -248,6 +342,24 @@ elif test "$datadir" = "\${datarootdir}"; then
 	datadir="$datarootdir"
 fi
 
+dnl Fix "mandir" variable if it hasn't been specified...
+if test "$mandir" = "\${prefix}/man" -a "$prefix" = "/usr"; then
+	case "$uname" in
+        	*BSD* | Darwin* | Linux*)
+        		# BSD, Darwin (macOS), and Linux
+        		mandir="/usr/share/man"
+        		;;
+        	IRIX*)
+        		# SGI IRIX
+        		mandir="/usr/share/catman/u_man"
+        		;;
+        	*)
+        		# All others
+        		mandir="/usr/man"
+        		;;
+	esac
+fi
+
 dnl EPM_SOFTWARE needs special attention for the default location...
 if test x$softwaredir = x; then
 	EPM_SOFTWARE="/etc/software"
diff --git a/tmp/epm/deb.c b/./epm/deb.c
index 59e7a80..1606e1f 100644
--- a/tmp/epm/deb.c
+++ b/./epm/deb.c
@@ -26,6 +26,31 @@
  * Local functions...
  */
 
+#ifdef __FOR_AOO__
+/*
+ * 'add_size()' - Append Installed-Size tag to DEBIAN/control file
+ */
+
+static int                      /* O - 0 = success, 1 = fail */
+add_size(FILE       *fpControl, /* Control file stream */
+         const char *directory) /* Directory containing all files to package */
+{
+    FILE *fp;
+    char command[1024];
+
+    snprintf(command, sizeof(command), "du -k -s %s", directory);
+    fp = popen(command, "r");
+    if( NULL != fp )
+    {
+        char size[1024];
+        fscanf(fp, "%s .", size);
+        fprintf(fpControl, "Installed-Size: %s\n", size);
+        return pclose(fp);
+    }
+    return 1;
+}
+#endif /* __FOR_AOO__ */
+
 static int	make_subpackage(const char *prodname, const char *directory,
 		                const char *platname, dist_t *dist,
 		                struct utsname *platform,
@@ -48,11 +73,34 @@ make_deb(const char     *prodname,	/* I - Product short name */
   char		name[1024],		/* Full product name */
 		filename[1024];		/* File to archive */
 
+#ifdef __FOR_AOO__
+  /*
+   * Use debian default naming scheme
+   */
+
+  if (!strcmp(platname, "intel"))
+#ifdef __FreeBSD_kernel__
+    platname = "kfreebsd-i386";
+#else
+    platname = "i386";
+#endif
+  else if (!strcmp(platname, "x86_64"))
+#ifdef __FreeBSD_kernel__
+    platname = "kfreebsd-amd64";
+#else
+    platname = "amd64";
+#endif
+  else if (!strcmp(platname, "ppc"))
+    platname = "powerpc";
+
+#else /* __FOR_AOO__ */
 
  /* Debian packages use "amd64" instead of "x86_64" for the architecture... */
   if (!strcmp(platname, "x86_64"))
     platname = "amd64";
 
+#endif /* __FOR_AOO__ */
+
   if (make_subpackage(prodname, directory, platname, dist, platform, NULL))
     return (1);
 
@@ -72,14 +120,26 @@ make_deb(const char     *prodname,	/* I - Product short name */
     */
 
     if (dist->release[0])
+#ifdef __FOR_AOO__
+      snprintf(name, sizeof(name), "%s_%s_%s", prodname, dist->version,
+#else /* __FOR_AOO__ */
       snprintf(name, sizeof(name), "%s-%s-%s", prodname, dist->version,
+#endif /* __FOR_AOO__ */
                dist->release);
     else
+#ifdef __FOR_AOO__
+      snprintf(name, sizeof(name), "%s_%s", prodname, dist->version);
+#else /* __FOR_AOO__ */
       snprintf(name, sizeof(name), "%s-%s", prodname, dist->version);
+#endif /* __FOR_AOO__ */
 
     if (platname[0])
     {
+#ifdef __FOR_AOO__
+      strlcat(name, "_", sizeof(name));
+#else /* __FOR_AOO__ */
       strlcat(name, "-", sizeof(name));
+#endif /* __FOR_AOO__ */
       strlcat(name, platname, sizeof(name));
     }
 
@@ -183,7 +243,11 @@ make_subpackage(const char     *prodname,
   */
 
   if (subpackage)
+#ifdef __FOR_AOO__
+    snprintf(prodfull, sizeof(prodfull), "%s_%s", prodname, subpackage);
+#else /* __FOR_AOO__ */
     snprintf(prodfull, sizeof(prodfull), "%s-%s", prodname, subpackage);
+#endif /* __FOR_AOO__ */
   else
     strlcpy(prodfull, prodname, sizeof(prodfull));
 
@@ -192,14 +256,26 @@ make_subpackage(const char     *prodname,
   */
 
   if (dist->release[0])
+#ifdef __FOR_AOO__
+    snprintf(name, sizeof(name), "%s_%s_%s", prodfull, dist->version,
+#else /* __FOR_AOO__ */
     snprintf(name, sizeof(name), "%s-%s-%s", prodfull, dist->version,
+#endif /* __FOR_AOO__ */
              dist->release);
   else
+#ifdef __FOR_AOO__
+    snprintf(name, sizeof(name), "%s_%s", prodfull, dist->version);
+#else /* __FOR_AOO__ */
     snprintf(name, sizeof(name), "%s-%s", prodfull, dist->version);
+#endif /* __FOR_AOO__ */
 
   if (platname[0])
   {
+#ifdef __FOR_AOO__
+    strlcat(name, "_", sizeof(name));
+#else /* __FOR_AOO__ */
     strlcat(name, "-", sizeof(name));
+#endif /* __FOR_AOO__ */
     strlcat(name, platname, sizeof(name));
   }
 
@@ -239,6 +315,24 @@ make_subpackage(const char     *prodname,
   * (which we change in get_platform to a common name)
   */
 
+#ifdef __FOR_AOO__
+  if (!strcmp(platform->machine, "intel"))
+#ifdef __FreeBSD_kernel__
+    fputs("Architecture: kfreebsd-i386\n", fp);
+#else
+    fputs("Architecture: i386\n", fp);
+#endif
+  else if (!strcmp(platform->machine, "x86_64"))
+#ifdef __FreeBSD_kernel__
+    fputs("Architecture: kfreebsd-amd64\n", fp);
+#else
+    fputs("Architecture: amd64\n", fp);
+#endif
+  else if (!strcmp(platform->machine, "ppc"))
+    fputs("Architecture: powerpc\n", fp);
+  else
+    fprintf(fp, "Architecture: %s\n", platform->machine);
+#else /* __FOR_AOO__ */
   if (!strcmp(platform->machine, "intel"))
     fputs("Architecture: i386\n", fp);
   if (!strcmp(platform->machine, "x86_64"))
@@ -247,6 +341,7 @@ make_subpackage(const char     *prodname,
     fputs("Architecture: powerpc\n", fp);
   else
     fprintf(fp, "Architecture: %s\n", platform->machine);
+#endif
 
   fprintf(fp, "Description: %s\n", dist->product);
   fprintf(fp, " Copyright: %s\n", dist->copyright);
@@ -504,6 +599,27 @@ make_subpackage(const char     *prodname,
 
   fclose(fp);
 
+#ifdef __FOR_AOO__
+  /*
+   * Calculate and append Installed-Size to DEBIAN/control
+   */
+
+  if (Verbosity)
+    puts("Calculating Installed-Size...");
+
+  snprintf(filename, sizeof(filename), "%s/%s/DEBIAN/control", directory, name);
+  if ((fp = fopen(filename, "a")) == NULL)
+  {
+    fprintf(stderr, "epm: Unable to Installed-Size to file \"%s\" - %s\n", filename,
+            strerror(errno));
+    return (1);
+  }
+
+  snprintf(filename, sizeof(filename), "%s/%s", directory, name);
+  add_size(fp, filename);
+  fclose(fp);
+#endif /* __FOR_AOO__ */
+
  /*
   * Copy the files over...
   */
diff --git a/tmp/epm/doc/1-intro.html b/./epm/doc/1-intro.html
index 9cad352..5fcc7d5 100644
--- a/tmp/epm/doc/1-intro.html
+++ b/./epm/doc/1-intro.html
@@ -50,6 +50,20 @@ any operating system from the same sources.</P>
 	<TH><FONT SIZE="-4">Map Files</FONT></TH>
 	<TH><FONT SIZE="-4">Un- install</FONT></TH>
 </TR>
+<TR>
+	<TD ALIGN="CENTER"><SMALL>installp</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>AIX</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+</TR>
 <TR>
 	<TD ALIGN="CENTER"><SMALL>pkg_add</SMALL></TD>
 	<TD ALIGN="CENTER"><SMALL>FreeBSD</SMALL></TD>
@@ -94,6 +108,34 @@ any operating system from the same sources.</P>
 	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
 	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
 </TR>
+<TR>
+	<TD ALIGN="CENTER"><SMALL>depot</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>HP-UX</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+</TR>
+<TR>
+	<TD ALIGN="CENTER"><SMALL>inst</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>IRIX</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+</TR>
 <TR>
 	<TD ALIGN="CENTER"><SMALL>Install.app</SMALL></TD>
 	<TD ALIGN="CENTER"><SMALL>macOS</SMALL></TD>
@@ -108,6 +150,20 @@ any operating system from the same sources.</P>
 	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
 	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
 </TR>
+<TR>
+	<TD ALIGN="CENTER"><SMALL>pkgadd</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Solaris</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+</TR>
 <TR>
 	<TD ALIGN="CENTER"><SMALL>rpm</SMALL></TD>
 	<TD ALIGN="CENTER"><SMALL>CentOS<BR>
@@ -124,6 +180,34 @@ any operating system from the same sources.</P>
 	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
 	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
 </TR>
+<TR>
+	<TD ALIGN="CENTER"><SMALL>setld</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Tru64 UNIX</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+</TR>
+<TR>
+	<TD ALIGN="CENTER"><SMALL>slackware</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Slackware Linux</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>No</SMALL></TD>
+	<TD ALIGN="CENTER"><SMALL>Yes</SMALL></TD>
+</TR>
 </TABLE>
 
 <OL>
diff --git a/tmp/epm/doc/2-building.html b/./epm/doc/2-building.html
index e6e3c33..84f9d83 100644
--- a/tmp/epm/doc/2-building.html
+++ b/./epm/doc/2-building.html
@@ -149,10 +149,28 @@ Installing EPM documentation in /usr/local/share/doc/epm
 	<TH>Operating System</TH>
 	<TH>Name</TH>
 </TR>
+<TR>
+	<TD>AIX</TD>
+	<TD><CODE>aix</CODE></TD>
+</TR>
+<TR>
+	<TD>Compaq Tru64 UNIX<BR>
+	Digital UNIX<BR>
+	OSF/1</TD>
+	<TD><CODE>tru64</CODE></TD>
+</TR>
 <TR>
 	<TD>FreeBSD</TD>
 	<TD><CODE>freebsd</CODE></TD>
 </TR>
+<TR>
+	<TD>HP-UX</TD>
+	<TD><CODE>hpux</CODE></TD>
+</TR>
+<TR>
+	<TD>IRIX</TD>
+	<TD><CODE>irix</CODE></TD>
+</TR>
 <TR>
 	<TD>Linux</TD>
 	<TD><CODE>linux</CODE></TD>
@@ -169,6 +187,10 @@ Installing EPM documentation in /usr/local/share/doc/epm
 	<TD>OpenBSD</TD>
 	<TD><CODE>openbsd</CODE></TD>
 </TR>
+<TR>
+	<TD>Solaris</TD>
+	<TD><CODE>solaris</CODE></TD>
+</TR>
 </TABLE></CENTER>
 
 <!-- NEED 3in -->
@@ -178,6 +200,14 @@ Installing EPM documentation in /usr/local/share/doc/epm
 	<TH>Processor(s)</TH>
 	<TH>Abbreviation</TH>
 </TR>
+<TR>
+	<TD>Compaq Alpha</TD>
+	<TD><CODE>alpha</CODE></TD>
+</TR>
+<TR>
+	<TD>HP Precision Architecture</TD>
+	<TD><CODE>hppa</CODE></TD>
+</TR>
 <TR>
 	<TD>INTEL 80x86</TD>
 	<TD><CODE>intel</CODE></TD>
@@ -225,6 +255,18 @@ Installing EPM documentation in /usr/local/share/doc/epm
 	<TH>Format</TH>
 	<TH>Command</TH>
 </TR>
+<TR>
+	<TD>AIX</TD>
+	<TD><CODE>aix</CODE></TD>
+	<TD NOWRAP><CODE>installp -d<I>directory</I> epm</CODE></TD>
+</TR>
+<TR>
+	<TD>Compaq Tru64 UNIX<BR>
+	Digital UNIX<BR>
+	OSF/1</TD>
+	<TD><CODE>setld</CODE></TD>
+	<TD NOWRAP><CODE>setld -a <I>directory</I></CODE></TD>
+</TR>
 <TR>
 	<TD>FreeBSD<BR>
 	NetBSD<BR>
@@ -233,6 +275,16 @@ Installing EPM documentation in /usr/local/share/doc/epm
 	<TD NOWRAP><CODE>cd <I>directory</I><BR>
 	pkg_add epm</CODE></TD>
 </TR>
+<TR>
+	<TD>HP-UX</TD>
+	<TD><CODE>depot</CODE></TD>
+	<TD NOWRAP><CODE>swinstall -f <I>directory</I></CODE></TD>
+</TR>
+<TR>
+	<TD>IRIX</TD>
+	<TD><CODE>inst</CODE></TD>
+	<TD NOWRAP><CODE>swmgr -f <I>directory</I></CODE></TD>
+</TR>
 <TR>
 	<TD>Linux</TD>
 	<TD><CODE>rpm</CODE></TD>
@@ -243,6 +295,11 @@ Installing EPM documentation in /usr/local/share/doc/epm
 	<TD><CODE>osx</CODE></TD>
 	<TD NOWRAP><CODE>open <I>directory</I>/<CODE>epm-4.1.pkg</CODE></TD>
 </TR>
+<TR>
+	<TD>Solaris</TD>
+	<TD><CODE>pkg</CODE></TD>
+	<TD NOWRAP><CODE>pkgadd -d <I>directory</I> epm</CODE></TD>
+</TR>
 </TABLE></CENTER>
 
 </BODY>
diff --git a/tmp/epm/doc/3-packaging.html b/./epm/doc/3-packaging.html
index 950b345..8786563 100644
--- a/tmp/epm/doc/3-packaging.html
+++ b/./epm/doc/3-packaging.html
@@ -113,6 +113,14 @@ provide them as a subpackage so that users that will not be
 developing add-ons to your software can omit them from the
 installation.</P>
 
+<CENTER><TABLE BORDER="1" WIDTH="80%" BGCOLOR="#cccccc" CELLPADDING="5">
+<TR><TD><B>Note:</B><BR>
+Subpackages are implemented as native subsets of the main package
+for the AIX, HPUX, IRIX, Solaris, and Tru64 formats and as
+separate packages that depend on the main (parent) package for
+all other formats.</TD></TR>
+</TABLE></CENTER>
+
 <P>To define a subpackage, use the <CODE>%subpackage</CODE>
 directive followed by a <CODE>%description</CODE> directive:</P>
 
@@ -226,21 +234,37 @@ macOS software packages.</P>
 
 <UL>
 
+	<LI><CODE>aix</CODE> - AIX software packages.
+
 	<LI><CODE>bsd</CODE> - FreeBSD, NetBSD, or OpenBSD
 	software packages.
 
+	<LI><CODE>depot</CODE> or <CODE>swinstall</CODE> - HP-UX
+	software packages.
+
 	<LI><CODE>dpkg</CODE> - Debian software packages.
 
+	<LI><CODE>inst</CODE> or <CODE>tardist</CODE> - IRIX
+	software packages.
+
 	<LI><CODE>native</CODE> - "Native" software packages
-	(RPM, etc.) for the platform.
+	(RPM, INST, DEPOT, PKG, etc.) for the platform.
 
 	<LI><CODE>osx</CODE> - macOS software packages.
 
+	<LI><CODE>pkg</CODE> - Solaris software packages.
+
 	<LI><CODE>portable</CODE> - Portable software
 	packages (default).
 
 	<LI><CODE>rpm</CODE> - Red Hat software packages.
 
+	<LI><CODE>setld</CODE> - Tru64 (setld) software
+	packages.
+
+	<LI><CODE>slackware</CODE> - Slackware software
+	packages.
+
 </UL>
 
 <P>Everything in the software list file stays the same - you just
@@ -263,12 +287,29 @@ directory is based on the operating system name, version, and
 architecture. Each package format will leave different files in
 the output directory.</P>
 
+<H3>AIX Package Files</H3>
+
+<P>AIX packages are contained in a file called
+<VAR>name.bff</VAR>, where "name" is the product/package name you
+supplied on the command-line.</P>
+
 <H3>BSD Package Files</H3>
 
 <P>BSD packages are contained in a file called
 <VAR>name.tgz</VAR>, where "name" is the product/package name you
 supplied on the command-line.</P>
 
+<H3>HP-UX Package Files</H3>
+
+<P>HP-UX packages are contained in two files called
+<VAR>name.depot.gz</VAR> and <VAR>name.depot.tgz</VAR>, where
+"name" is the product/package name you supplied on the
+command-line. The <VAR>name.depot.gz</VAR> file can be supplied
+directly to the <CODE>swinstall(1m)</CODE> command, while the
+<VAR>name.depot.tgz</VAR> file contains a compressed
+<CODE>tar(1)</CODE> archive that can be used to install the
+software from CD-ROM or network filesystem.</P>
+
 <H3>Debian Package Files</H3>
 
 <P>Debian packages are contained in a file called
@@ -279,6 +320,12 @@ contains a compressed <CODE>tar</CODE> archive containing
 <VAR>name.deb</VAR> and <VAR>name-subpackage.deb</VAR> files that
 can be installed from CD-ROM, disk, or network filesystem.</P>
 
+<H3>IRIX Package Files</H3>
+
+<P>IRIX packages are contained in a file called
+<VAR>name.tardist</VAR>, where "name" is the product/package name
+you supplied on the command-line.</P>
+
 <H3>macOS Package Files</H3>
 
 <P>macOS packages are contained in a file called
@@ -295,5 +342,28 @@ contains a compressed <CODE>tar</CODE> archive containing
 <VAR>name.rpm</VAR> and <VAR>name-subpackage.rpm</VAR> files that
 can be installed from CD-ROM, disk, or network filesystem.</P>
 
+<H3>Slackware Package Files</H3>
+
+<P>Slackware packages are contained in a file called
+<VAR>name.tgz</VAR>, where "name" is the product/package name you
+supplied on the command-line.</P>
+
+<H3>Solaris Package Files</H3>
+
+<P>Solaris packages are contained in two files called
+<VAR>name.pkg.gz</VAR> and <VAR>name.pkg.tgz</VAR>, where "name"
+is the product/package name you supplied on the command-line. The
+<VAR>name.pkg.gz</VAR> file is a compressed package file that can
+be used directly with the <CODE>pkgadd(1m)</CODE> command, while
+the <VAR>name.pkg.tgz</VAR> file is a compressed <CODE>tar</CODE>
+archive that can be used to install the software from CD-ROM,
+disk, or network filesystem.</P>
+
+<H3>Tru64 Package Files</H3>
+
+<P>Tru64 packages are contained in a file called
+<VAR>name.tar.gz</VAR>, where "name" is the product/package name
+you supplied on the command-line.</P>
+
 </BODY>
 </HTML>
diff --git a/tmp/epm/doc/4-advanced.html b/./epm/doc/4-advanced.html
index 7ba68de..09afc17 100644
--- a/tmp/epm/doc/4-advanced.html
+++ b/./epm/doc/4-advanced.html
@@ -35,6 +35,13 @@ each package format.</P>
 	<TH>%replaces</TH>
 	<TH>%requires</TH>
 </TR>
+<TR>
+	<TD ALIGN="CENTER">aix</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+</TR>
 <TR>
 	<TD ALIGN="CENTER">bsd</TD>
 	<TD ALIGN="CENTER">Yes</TD>
@@ -49,6 +56,13 @@ each package format.</P>
 	<TD ALIGN="CENTER">Yes</TD>
 	<TD ALIGN="CENTER">Yes</TD>
 </TR>
+<TR>
+	<TD ALIGN="CENTER">inst</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+</TR>
 <TR>
 	<TD ALIGN="CENTER">osx</TD>
 	<TD ALIGN="CENTER">No</TD>
@@ -56,6 +70,13 @@ each package format.</P>
 	<TD ALIGN="CENTER">No</TD>
 	<TD ALIGN="CENTER">No</TD>
 </TR>
+<TR>
+	<TD ALIGN="CENTER">pkg</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+</TR>
 <TR>
 	<TD ALIGN="CENTER">portable</TD>
 	<TD ALIGN="CENTER">Yes</TD>
@@ -70,6 +91,27 @@ each package format.</P>
 	<TD ALIGN="CENTER">No</TD>
 	<TD ALIGN="CENTER">Yes</TD>
 </TR>
+<TR>
+	<TD ALIGN="CENTER">setld</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">No</TD>
+</TR>
+<TR>
+	<TD ALIGN="CENTER">slackware</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">No</TD>
+</TR>
+<TR>
+	<TD ALIGN="CENTER">swinstall</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+</TR>
 </TABLE></CENTER>
 
 <OL>
@@ -170,6 +212,15 @@ of the software:</P>
 	<TH><SMALL>%preremove</SMALL></TH>
 	<TH><SMALL>%postremove</SMALL></TH>
 </TR>
+<TR>
+	<TD ALIGN="CENTER">aix</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+</TR>
 <TR>
 	<TD ALIGN="CENTER">bsd</TD>
 	<TD ALIGN="CENTER">No</TD>
@@ -188,6 +239,15 @@ of the software:</P>
 	<TD ALIGN="CENTER">Yes</TD>
 	<TD ALIGN="CENTER">Yes</TD>
 </TR>
+<TR>
+	<TD ALIGN="CENTER">inst</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+</TR>
 <TR>
 	<TD ALIGN="CENTER">osx</TD>
 	<TD ALIGN="CENTER">Yes</TD>
@@ -197,6 +257,15 @@ of the software:</P>
 	<TD ALIGN="CENTER">No</TD>
 	<TD ALIGN="CENTER">No</TD>
 </TR>
+<TR>
+	<TD ALIGN="CENTER">pkg</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+</TR>
 <TR>
 	<TD ALIGN="CENTER">portable</TD>
 	<TD ALIGN="CENTER">Yes</TD>
@@ -215,6 +284,33 @@ of the software:</P>
 	<TD ALIGN="CENTER">Yes</TD>
 	<TD ALIGN="CENTER">Yes</TD>
 </TR>
+<TR>
+	<TD ALIGN="CENTER">setld</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+</TR>
+<TR>
+	<TD ALIGN="CENTER">slackware</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">No</TD>
+</TR>
+<TR>
+	<TD ALIGN="CENTER">swinstall</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">No</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+	<TD ALIGN="CENTER">Yes</TD>
+</TR>
 </TABLE></CENTER>
 
 <P>&nbsp;</P>
@@ -488,6 +584,21 @@ Priority: extra
 EOF
 </PRE>
 
+<H3>PKG Literal Data</H3>
+
+<P>PKG packages support request files that are used to do batch
+installations when installation commands require user input.  The
+<CODE>%literal(request)</CODE> directive can be used to provide this user
+input:</P>
+
+<PRE>
+%literal(request) &lt;&lt;EOF
+John Doe
+1 Any Lane
+Forest Lawn, OH 12345
+EOF
+</PRE>
+
 <H3>RPM Literal Data</H3>
 
 <P>RPM packages support numerous attributes in the "spec" file that control
diff --git a/tmp/epm/doc/epm-book.html b/./epm/doc/epm-book.html
index ad5df73..acabc73 100644
--- a/tmp/epm/doc/epm-book.html
+++ b/./epm/doc/epm-book.html
@@ -191,9 +191,15 @@ A { text-decoration: none; }
 </dt>
 <dd>Debian Developers' Corner
 <br> &nbsp;</dd>
+<dt><a HREF="http://techpubs.sgi.com/">http://techpubs.sgi.com/</a></dt>
+<dd>IRIX Documentation On-Line
+<br> &nbsp;</dd>
 <dt><a HREF="http://www.rpm.org/">http://www.rpm.org/</a></dt>
 <dd>The Red Hat Package Manager home page.
 <br> &nbsp;</dd>
+<dt><a HREF="http://docs.sun.com/">http://docs.sun.com/</a></dt>
+<dd>Solaris Documentation On-Line
+<br> &nbsp;</dd>
 </dl>
 <h2><a NAME="1_4">Help Me Improve This Book!</a></h2>
 <p>I've done my best to ensure that this book is both accurate and
@@ -290,6 +296,13 @@ https://www.cups.org/</a>) in 1997, the initial goal was to add support
 Re- places</font></th><th><font SIZE="-4">Config Files</font></th><th><font
 SIZE="-4">Map Files</font></th><th><font SIZE="-4">Un- install</font></th>
 </tr>
+<tr><td ALIGN="CENTER"><small>installp</small></td><td ALIGN="CENTER"><small>
+AIX</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
+<small>No</small></td><td ALIGN="CENTER"><small>No</small></td><td ALIGN="CENTER">
+<small>No</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
+<small>Yes</small></td><td ALIGN="CENTER"><small>No</small></td><td ALIGN="CENTER">
+<small>No</small></td><td ALIGN="CENTER"><small>No</small></td><td ALIGN="CENTER">
+<small>Yes</small></td></tr>
 <tr><td ALIGN="CENTER"><small>pkg_add</small></td><td ALIGN="CENTER"><small>
 FreeBSD</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
 <small>Yes<sup>2</sup></small></td><td ALIGN="CENTER"><small>No</small></td><td
@@ -313,6 +326,20 @@ No</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
 <small>Yes</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
 <small>Yes</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
 <small>No</small></td><td ALIGN="CENTER"><small>Yes</small></td></tr>
+<tr><td ALIGN="CENTER"><small>depot</small></td><td ALIGN="CENTER"><small>
+HP-UX</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
+<small>No</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
+<small>Yes</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
+<small>Yes</small></td><td ALIGN="CENTER"><small>No</small></td><td ALIGN="CENTER">
+<small>Yes</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
+<small>Yes</small></td></tr>
+<tr><td ALIGN="CENTER"><small>inst</small></td><td ALIGN="CENTER"><small>
+IRIX</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
+<small>No</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
+<small>Yes</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
+<small>Yes</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
+<small>Yes</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
+<small>Yes</small></td></tr>
 <tr><td ALIGN="CENTER"><small>Install.app</small></td><td ALIGN="CENTER">
 <small>macOS</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
 <small>No</small></td><td ALIGN="CENTER"><small>No</small></td><td ALIGN="CENTER">
@@ -320,6 +347,13 @@ No</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
 <small>No</small></td><td ALIGN="CENTER"><small>No</small></td><td ALIGN="CENTER">
 <small>No</small></td><td ALIGN="CENTER"><small>No</small></td><td ALIGN="CENTER">
 <small>No</small></td></tr>
+<tr><td ALIGN="CENTER"><small>pkgadd</small></td><td ALIGN="CENTER"><small>
+Solaris</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
+<small>No</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
+<small>No</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
+<small>Yes</small></td><td ALIGN="CENTER"><small>No</small></td><td ALIGN="CENTER">
+<small>Yes</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
+<small>Yes</small></td></tr>
 <tr><td ALIGN="CENTER"><small>rpm</small></td><td ALIGN="CENTER"><small>
 CentOS
 <br> Red Hat
@@ -328,6 +362,22 @@ CentOS
 ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER"><small>Yes</small>
 </td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER"><small>
 No</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
+<small>Yes</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
+<small>No</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
+<small>No</small></td><td ALIGN="CENTER"><small>Yes</small></td></tr>
+<tr><td ALIGN="CENTER"><small>setld</small></td><td ALIGN="CENTER"><small>
+Tru64 UNIX</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
+<small>No</small></td><td ALIGN="CENTER"><small>No</small></td><td ALIGN="CENTER">
+<small>No</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
+<small>Yes</small></td><td ALIGN="CENTER"><small>No</small></td><td ALIGN="CENTER">
+<small>No</small></td><td ALIGN="CENTER"><small>No</small></td><td ALIGN="CENTER">
+<small>Yes</small></td></tr>
+<tr><td ALIGN="CENTER"><small>slackware</small></td><td ALIGN="CENTER"><small>
+Slackware Linux</small></td><td ALIGN="CENTER"><small>Yes</small></td><td
+ALIGN="CENTER"><small>No</small></td><td ALIGN="CENTER"><small>No</small>
+</td><td ALIGN="CENTER"><small>No</small></td><td ALIGN="CENTER"><small>
+Yes</small></td><td ALIGN="CENTER"><small>Yes</small></td><td ALIGN="CENTER">
+<small>No</small></td><td ALIGN="CENTER"><small>No</small></td><td ALIGN="CENTER">
 <small>No</small></td><td ALIGN="CENTER"><small>Yes</small></td></tr>
 </table>
 <ol>
@@ -541,11 +591,18 @@ Installing EPM documentation in /usr/local/share/doc/epm
 <table BORDER="1" CELLPADDING="2"><caption> <a NAME="TABLE_2_1">Table
  2.1: Operating System Name Abbreviations</a></caption>
 <tr><th>Operating System</th><th>Name</th></tr>
+<tr><td>AIX</td><td><code>aix</code></td></tr>
+<tr><td>Compaq Tru64 UNIX
+<br> Digital UNIX
+<br> OSF/1</td><td><code>tru64</code></td></tr>
 <tr><td>FreeBSD</td><td><code>freebsd</code></td></tr>
+<tr><td>HP-UX</td><td><code>hpux</code></td></tr>
+<tr><td>IRIX</td><td><code>irix</code></td></tr>
 <tr><td>Linux</td><td><code>linux</code></td></tr>
 <tr><td>macOS</td><td><code>osx</code></td></tr>
 <tr><td>NetBSD</td><td><code>netbsd</code></td></tr>
 <tr><td>OpenBSD</td><td><code>openbsd</code></td></tr>
+<tr><td>Solaris</td><td><code>solaris</code></td></tr>
 </table>
 </center>
 
@@ -554,6 +611,8 @@ Installing EPM documentation in /usr/local/share/doc/epm
 <table BORDER="1" CELLPADDING="2"><caption> <a NAME="TABLE_2_2">Table
  2.2: Processor Architecture Abbreviations</a></caption>
 <tr><th>Processor(s)</th><th>Abbreviation</th></tr>
+<tr><td>Compaq Alpha</td><td><code>alpha</code></td></tr>
+<tr><td>HP Precision Architecture</td><td><code>hppa</code></td></tr>
 <tr><td>INTEL 80x86</td><td><code>intel</code></td></tr>
 <tr><td>INTEL 80x86 w/64bit Extensions</td><td><code>x86_64</code></td></tr>
 <tr><td>MIPS RISC</td><td><code>mips</code></td></tr>
@@ -585,15 +644,27 @@ Installing EPM documentation in /usr/local/share/doc/epm
 <table BORDER="1" CELLPADDING="2"><caption> <a NAME="TABLE_2_3">Table
  2.3: Native Operating System Formats</a></caption>
 <tr><th>Operating System</th><th>Format</th><th>Command</th></tr>
+<tr><td>AIX</td><td><code>aix</code></td><td NOWRAP><code>installp -d<i>
+directory</i> epm</code></td></tr>
+<tr><td>Compaq Tru64 UNIX
+<br> Digital UNIX
+<br> OSF/1</td><td><code>setld</code></td><td NOWRAP><code>setld -a<i>
+ directory</i></code></td></tr>
 <tr><td>FreeBSD
 <br> NetBSD
 <br> OpenBSD</td><td><code>bsd</code></td><td NOWRAP><code>cd<i>
  directory</i>
 <br> pkg_add epm</code></td></tr>
+<tr><td>HP-UX</td><td><code>depot</code></td><td NOWRAP><code>swinstall
+ -f<i> directory</i></code></td></tr>
+<tr><td>IRIX</td><td><code>inst</code></td><td NOWRAP><code>swmgr -f<i>
+ directory</i></code></td></tr>
 <tr><td>Linux</td><td><code>rpm</code></td><td NOWRAP><code>rpm -i<i>
  directory</i>/epm-4.1.rpm</code></td></tr>
 <tr><td>macOS</td><td><code>osx</code></td><td NOWRAP><code>open<i>
  directory</i>/<code>epm-4.1.pkg</code></code></td></tr>
+<tr><td>Solaris</td><td><code>pkg</code></td><td NOWRAP><code>pkgadd -d<i>
+ directory</i> epm</code></td></tr>
 </table>
 </center>
 <HR NOSHADE>
@@ -684,6 +755,15 @@ f 0444 root sys /usr/share/doc/foo/foo.html foo.html
  if your package includes developer files, you might provide them as a
  subpackage so that users that will not be developing add-ons to your
  software can omit them from the installation.</p>
+<center>
+<table BGCOLOR="#cccccc" BORDER="1" CELLPADDING="5" WIDTH="80%">
+<tr><td><b>Note:</b>
+<br> Subpackages are implemented as native subsets of the main package
+ for the AIX, HPUX, IRIX, Solaris, and Tru64 formats and as separate
+ packages that depend on the main (parent) package for all other
+ formats.</td></tr>
+</table>
+</center>
 <p>To define a subpackage, use the <code>%subpackage</code> directive
  followed by a <code>%description</code> directive:</p>
 <pre>
@@ -770,13 +850,20 @@ Figure 3.1</a>). To include the setup program in your distributions,
 </pre>
 <p>The<i> format</i> option can be one of the following keywords:</p>
 <ul>
+<li><code>aix</code> - AIX software packages.</li>
 <li><code>bsd</code> - FreeBSD, NetBSD, or OpenBSD software packages.</li>
+<li><code>depot</code> or <code>swinstall</code> - HP-UX software
+ packages.</li>
 <li><code>dpkg</code> - Debian software packages.</li>
-<li><code>native</code> - &quot;Native&quot; software packages (RPM, etc.) for the
- platform.</li>
+<li><code>inst</code> or <code>tardist</code> - IRIX software packages.</li>
+<li><code>native</code> - &quot;Native&quot; software packages (RPM, INST, DEPOT,
+ PKG, etc.) for the platform.</li>
 <li><code>osx</code> - macOS software packages.</li>
+<li><code>pkg</code> - Solaris software packages.</li>
 <li><code>portable</code> - Portable software packages (default).</li>
 <li><code>rpm</code> - Red Hat software packages.</li>
+<li><code>setld</code> - Tru64 (setld) software packages.</li>
+<li><code>slackware</code> - Slackware software packages.</li>
 </ul>
 <p>Everything in the software list file stays the same - you just use
  the <code>-f</code> option to select the format. For example, to build
@@ -792,10 +879,22 @@ epm -f rpm epm
  Portable Distribution&quot;</a>, the default output directory is based on
  the operating system name, version, and architecture. Each package
  format will leave different files in the output directory.</p>
+<h3>AIX Package Files</h3>
+<p>AIX packages are contained in a file called<var> name.bff</var>,
+ where &quot;name&quot; is the product/package name you supplied on the
+ command-line.</p>
 <h3>BSD Package Files</h3>
 <p>BSD packages are contained in a file called<var> name.tgz</var>,
  where &quot;name&quot; is the product/package name you supplied on the
  command-line.</p>
+<h3>HP-UX Package Files</h3>
+<p>HP-UX packages are contained in two files called<var> name.depot.gz</var>
+ and<var> name.depot.tgz</var>, where &quot;name&quot; is the product/package name
+ you supplied on the command-line. The<var> name.depot.gz</var> file can
+ be supplied directly to the <code>swinstall(1m)</code> command, while
+ the<var> name.depot.tgz</var> file contains a compressed <code>tar(1)</code>
+ archive that can be used to install the software from CD-ROM or network
+ filesystem.</p>
 <h3>Debian Package Files</h3>
 <p>Debian packages are contained in a file called<var> name.deb</var> or<var>
  name.deb.tgz</var> when there are subpackages, where &quot;name&quot; is the
@@ -803,6 +902,10 @@ epm -f rpm epm
  name.deb.tgz</var> file contains a compressed <code>tar</code> archive
  containing<var> name.deb</var> and<var> name-subpackage.deb</var> files
  that can be installed from CD-ROM, disk, or network filesystem.</p>
+<h3>IRIX Package Files</h3>
+<p>IRIX packages are contained in a file called<var> name.tardist</var>,
+ where &quot;name&quot; is the product/package name you supplied on the
+ command-line.</p>
 <h3>macOS Package Files</h3>
 <p>macOS packages are contained in a file called<var> name.dmg</var>,
  where &quot;name&quot; is the product/package name you supplied on the
@@ -814,6 +917,22 @@ epm -f rpm epm
  name.rpm.tgz</var> file contains a compressed <code>tar</code> archive
  containing<var> name.rpm</var> and<var> name-subpackage.rpm</var> files
  that can be installed from CD-ROM, disk, or network filesystem.</p>
+<h3>Slackware Package Files</h3>
+<p>Slackware packages are contained in a file called<var> name.tgz</var>
+, where &quot;name&quot; is the product/package name you supplied on the
+ command-line.</p>
+<h3>Solaris Package Files</h3>
+<p>Solaris packages are contained in two files called<var> name.pkg.gz</var>
+ and<var> name.pkg.tgz</var>, where &quot;name&quot; is the product/package name
+ you supplied on the command-line. The<var> name.pkg.gz</var> file is a
+ compressed package file that can be used directly with the <code>
+pkgadd(1m)</code> command, while the<var> name.pkg.tgz</var> file is a
+ compressed <code>tar</code> archive that can be used to install the
+ software from CD-ROM, disk, or network filesystem.</p>
+<h3>Tru64 Package Files</h3>
+<p>Tru64 packages are contained in a file called<var> name.tar.gz</var>,
+ where &quot;name&quot; is the product/package name you supplied on the
+ command-line.</p>
 <HR NOSHADE>
 <h1><a NAME="ADVANCED">4 - Advanced Packaging with EPM</a></h1>
 <p>This chapter describes the advanced packaging features of EPM.</p>
@@ -836,17 +955,29 @@ epm -f rpm epm
  4.1: Dependency Support</a></caption>
 <tr><th>Format</th><th>%incompat</th><th>%provides</th><th>%replaces</th><th>
 %requires</th></tr>
+<tr><td ALIGN="CENTER">aix</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">
+No</td><td ALIGN="CENTER">Yes</td><td ALIGN="CENTER">Yes</td></tr>
 <tr><td ALIGN="CENTER">bsd</td><td ALIGN="CENTER">Yes</td><td ALIGN="CENTER">
 No</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">Yes</td></tr>
 <tr><td ALIGN="CENTER">deb</td><td ALIGN="CENTER">Yes</td><td ALIGN="CENTER">
 Yes<sup>1</sup></td><td ALIGN="CENTER">Yes</td><td ALIGN="CENTER">Yes</td>
 </tr>
+<tr><td ALIGN="CENTER">inst</td><td ALIGN="CENTER">Yes</td><td ALIGN="CENTER">
+No</td><td ALIGN="CENTER">Yes</td><td ALIGN="CENTER">Yes</td></tr>
 <tr><td ALIGN="CENTER">osx</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">
 No</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">No</td></tr>
+<tr><td ALIGN="CENTER">pkg</td><td ALIGN="CENTER">Yes</td><td ALIGN="CENTER">
+No</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">Yes</td></tr>
 <tr><td ALIGN="CENTER">portable</td><td ALIGN="CENTER">Yes</td><td ALIGN="CENTER">
 Yes</td><td ALIGN="CENTER">Yes</td><td ALIGN="CENTER">Yes</td></tr>
 <tr><td ALIGN="CENTER">rpm</td><td ALIGN="CENTER">Yes</td><td ALIGN="CENTER">
 Yes</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">Yes</td></tr>
+<tr><td ALIGN="CENTER">setld</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">
+No</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">No</td></tr>
+<tr><td ALIGN="CENTER">slackware</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">
+No</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">No</td></tr>
+<tr><td ALIGN="CENTER">swinstall</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">
+No</td><td ALIGN="CENTER">Yes</td><td ALIGN="CENTER">Yes</td></tr>
 </table>
 </center>
 <ol>
@@ -917,21 +1048,39 @@ Table 4.2</a> shows the support for scripts in each package format.</p>
 <small>%postinstall</small></th><th><small>%prepatch</small></th><th><small>
 %postpatch</small></th><th><small>%preremove</small></th><th><small>
 %postremove</small></th></tr>
+<tr><td ALIGN="CENTER">aix</td><td ALIGN="CENTER">Yes</td><td ALIGN="CENTER">
+Yes</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">
+Yes</td><td ALIGN="CENTER">Yes</td></tr>
 <tr><td ALIGN="CENTER">bsd</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">
 Yes</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">
 Yes</td><td ALIGN="CENTER">No</td></tr>
 <tr><td ALIGN="CENTER">deb</td><td ALIGN="CENTER">Yes</td><td ALIGN="CENTER">
 Yes</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">
 Yes</td><td ALIGN="CENTER">Yes</td></tr>
+<tr><td ALIGN="CENTER">inst</td><td ALIGN="CENTER">Yes</td><td ALIGN="CENTER">
+Yes</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">
+Yes</td><td ALIGN="CENTER">Yes</td></tr>
 <tr><td ALIGN="CENTER">osx</td><td ALIGN="CENTER">Yes</td><td ALIGN="CENTER">
 Yes</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">
 No</td><td ALIGN="CENTER">No</td></tr>
+<tr><td ALIGN="CENTER">pkg</td><td ALIGN="CENTER">Yes</td><td ALIGN="CENTER">
+Yes</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">
+Yes</td><td ALIGN="CENTER">Yes</td></tr>
 <tr><td ALIGN="CENTER">portable</td><td ALIGN="CENTER">Yes</td><td ALIGN="CENTER">
 Yes</td><td ALIGN="CENTER">Yes</td><td ALIGN="CENTER">Yes</td><td ALIGN="CENTER">
 Yes</td><td ALIGN="CENTER">Yes</td></tr>
 <tr><td ALIGN="CENTER">rpm</td><td ALIGN="CENTER">Yes</td><td ALIGN="CENTER">
 Yes</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">
 Yes</td><td ALIGN="CENTER">Yes</td></tr>
+<tr><td ALIGN="CENTER">setld</td><td ALIGN="CENTER">Yes</td><td ALIGN="CENTER">
+Yes</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">
+Yes</td><td ALIGN="CENTER">Yes</td></tr>
+<tr><td ALIGN="CENTER">slackware</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">
+Yes</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">
+No</td><td ALIGN="CENTER">No</td></tr>
+<tr><td ALIGN="CENTER">swinstall</td><td ALIGN="CENTER">Yes</td><td ALIGN="CENTER">
+Yes</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">No</td><td ALIGN="CENTER">
+Yes</td><td ALIGN="CENTER">Yes</td></tr>
 </table>
 </center>
 <p>&nbsp;</p>
@@ -1130,6 +1279,18 @@ Section: misc
 Priority: extra
 EOF
 </pre>
+<h3>PKG Literal Data</h3>
+<p>PKG packages support request files that are used to do batch
+ installations when installation commands require user input. The <code>
+%literal(request)</code> directive can be used to provide this user
+ input:</p>
+<pre>
+%literal(request) &lt;&lt;EOF
+John Doe
+1 Any Lane
+Forest Lawn, OH 12345
+EOF
+</pre>
 <h3>RPM Literal Data</h3>
 <p>RPM packages support numerous attributes in the &quot;spec&quot; file that
  control how the package is created and what metadata is included with
@@ -1519,23 +1680,41 @@ product</i>.list&quot;.
 <dd style="margin-left: 5.0em">Specifies the actual architecture for the
  software. Without this option the generic processor architecture is
  used (&quot;intel&quot;, &quot;sparc&quot;, &quot;mips&quot;, etc.)</dd>
+<dt><b>-f aix</b></dt>
+<dd style="margin-left: 5.0em">Generate an AIX distribution suitable for
+ installation on an AIX system.</dd>
 <dt><b>-f bsd</b></dt>
 <dd style="margin-left: 5.0em">Generate a BSD distribution suitable for
  installation on a FreeBSD, NetBSD, or OpenBSD system.</dd>
 <dt><b>-f deb</b></dt>
 <dd style="margin-left: 5.0em">Generate a Debian distribution suitable
- for installation on a Debian-based Linux system.</dd>
+ for installation on a Debian Linux system.</dd>
+<dt><b>-f inst</b></dt>
+<dd style="margin-left: 5.0em"></dd>
+<dt><b>-f tardist</b></dt>
+<dd style="margin-left: 5.0em">Generate an IRIX distribution suitable
+ for installation on an system running IRIX.</dd>
+<dt><b>-f lsb</b></dt>
+<dd style="margin-left: 5.0em"></dd>
+<dt><b>-f lsb-signed</b></dt>
+<dd style="margin-left: 5.0em">Generate RPM packages for LSB-conforming
+ systems. The<i> lsb-signed</i> format uses the GPG private key you have
+ defined in the ~/.rpmmacros file.</dd>
 <dt><b>-f native</b></dt>
 <dd style="margin-left: 5.0em">Generate a native distribution. This uses<i>
- deb</i> or<i> rpm</i> for Linux,<i> bsd</i> for FreeBSD, NetBSD, and
- OpenBSD, and<i> macos</i> for macOS. All other operating systems
- default to the<i> portable</i> format.</dd>
+ rpm</i> for Linux,<i> inst</i> for IRIX,<i> pkg</i> for Solaris,<i>
+ swinstall</i> for HP-UX,<i> bsd</i> for FreeBSD, NetBSD, and OpenBSD,
+ and<i> osx</i> for macOS. All other operating systems default to the<i>
+ portable</i> format.</dd>
 <dt><b>-f macos</b></dt>
 <dd style="margin-left: 5.0em"></dd>
 <dt><b>-f macos-signed</b></dt>
 <dd style="margin-left: 5.0em">Generate a macOS software package. The<i>
  macos-signed</i> format uses the signing identity in the
  EPM_SIGNING_IDENTITY environment variable.</dd>
+<dt><b>-f pkg</b></dt>
+<dd style="margin-left: 5.0em">Generate an AT&amp;T software package. These
+ are used primarily under Solaris.</dd>
 <dt><b>-f portable</b></dt>
 <dd style="margin-left: 5.0em">Generate a portable distribution based on
  shell scripts and tar files. The resulting distribution is installed
@@ -1547,6 +1726,16 @@ product</i>.list&quot;.
  (&quot;RPM&quot;) distribution suitable for installation on an RPM-based Linux
  system. The<i> rpm-signed</i> format uses the GPG private key you have
  defined in the ~/.rpmmacros file.</dd>
+<dt><b>-f setld</b></dt>
+<dd style="margin-left: 5.0em">Generate a Tru64 (setld) software
+ distribution.</dd>
+<dt><b>-f slackware</b></dt>
+<dd style="margin-left: 5.0em">Generate a Slackware Linux software
+ distribution.</dd>
+<dt><b>-f swinstall</b></dt>
+<dd style="margin-left: 5.0em"></dd>
+<dt><b>-f depot</b></dt>
+<dd style="margin-left: 5.0em">Generate a HP-UX software distribution.</dd>
 <dt><b>-g</b></dt>
 <dd style="margin-left: 5.0em">Disable stripping of executable files in
  the distribution.</dd>
diff --git a/tmp/epm/doc/epm.html b/./epm/doc/epm.html
index 893d7c7..bb873b9 100644
--- a/tmp/epm/doc/epm.html
+++ b/./epm/doc/epm.html
@@ -70,25 +70,44 @@ The following options are recognized:
 <dt><b>-a </b><i>architecture</i>
 <dd style="margin-left: 5.0em">Specifies the actual architecture for the software.
 Without this option the generic processor architecture is used ("intel", "sparc", "mips", etc.)
+<dt><b>-f aix</b>
+<dd style="margin-left: 5.0em">Generate an AIX distribution suitable for installation on an AIX system.
 <dt><b>-f bsd</b>
 <dd style="margin-left: 5.0em">Generate a BSD distribution suitable for installation on a FreeBSD, NetBSD, or OpenBSD system.
 <dt><b>-f deb</b>
-<dd style="margin-left: 5.0em">Generate a Debian distribution suitable for installation on a Debian-based Linux system.
+<dd style="margin-left: 5.0em">Generate a Debian distribution suitable for installation on a Debian Linux system.
+<dt><b>-f inst</b>
+<dd style="margin-left: 5.0em"><dt><b>-f tardist</b>
+<dd style="margin-left: 5.0em">Generate an IRIX distribution suitable for installation on an system running IRIX.
+<dt><b>-f lsb</b>
+<dd style="margin-left: 5.0em"><dt><b>-f lsb-signed</b>
+<dd style="margin-left: 5.0em">Generate RPM packages for LSB-conforming systems.
+The <i>lsb-signed</i> format uses the GPG private key you have defined in the ~/.rpmmacros file.
 <dt><b>-f native</b>
 <dd style="margin-left: 5.0em">Generate a native distribution.
-This uses <i>deb</i> or <i>rpm</i> for Linux, <i>bsd</i> for FreeBSD, NetBSD, and OpenBSD, and <i>macos</i> for macOS.
+This uses <i>rpm</i> for Linux, <i>inst</i> for IRIX, <i>pkg</i> for Solaris, <i>swinstall</i> for HP-UX, <i>bsd</i> for FreeBSD, NetBSD, and OpenBSD, and <i>osx</i> for macOS.
 All other operating systems default to the <i>portable</i> format.
 <dt><b>-f macos</b>
 <dd style="margin-left: 5.0em"><dt><b>-f macos-signed</b>
 <dd style="margin-left: 5.0em">Generate a macOS software package.
 The <i>macos-signed</i> format uses the signing identity in the EPM_SIGNING_IDENTITY environment variable.
+<dt><b>-f pkg</b>
+<dd style="margin-left: 5.0em">Generate an AT&amp;T software package.
+These are used primarily under Solaris.
 <dt><b>-f portable</b>
 <dd style="margin-left: 5.0em">Generate a portable distribution based on shell scripts and tar files.
 The resulting distribution is installed and removed the same way on all operating systems. [default]
 <dt><b>-f rpm</b>
 <dd style="margin-left: 5.0em"><dt><b>-f rpm-signed</b>
-<dd style="margin-left: 5.0em">Generate a Red Hat Package Manager ("RPM") distribution suitable for installation on an RPM-based Linux system.
+<dd style="margin-left: 5.0em">Generate a Red Hat Package Manager ("RPM") distribution suitable for installation on a Red Hat Linux system.
 The <i>rpm-signed</i> format uses the GPG private key you have defined in the ~/.rpmmacros file.
+<dt><b>-f setld</b>
+<dd style="margin-left: 5.0em">Generate a Tru64 (setld) software distribution.
+<dt><b>-f slackware</b>
+<dd style="margin-left: 5.0em">Generate a Slackware Linux software distribution.
+<dt><b>-f swinstall</b>
+<dd style="margin-left: 5.0em"><dt><b>-f depot</b>
+<dd style="margin-left: 5.0em">Generate a HP-UX software distribution.
 <dt><b>-g</b>
 <dd style="margin-left: 5.0em">Disable stripping of executable files in the distribution.
 <dt><b>-k</b>
diff --git a/./epm/doc/epm.list.man b/./epm/doc/epm.list.man
new file mode 100644
index 0000000..5d152fe
--- /dev/null
+++ b/./epm/doc/epm.list.man
@@ -0,0 +1,295 @@
+.\"
+.\" Manual page for the ESP Package Manager (EPM) list file format.
+.\"
+.\" Copyright 1999-2017 by Michael R Sweet
+.\" Copyright 1999-2010 by Easy Software Products, all rights reserved.
+.\"
+.\" This program is free software; you can redistribute it and/or modify
+.\" it under the terms of the GNU General Public License as published by
+.\" the Free Software Foundation; either version 2, or (at your option)
+.\" any later version.
+.\"
+.\" This program is distributed in the hope that it will be useful,
+.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
+.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+.\" GNU General Public License for more details.
+.\"
+.TH epm.list 5 "ESP Package Manager" "3 October 2017" "Michael R Sweet"
+.SH NAME
+epm.list \- epm list file format.
+.SH DESCRIPTION
+Each
+.BR epm (1)
+product has an associated list file that describes the files to include with the product.
+Comment lines begin with the "#" character and are ignored.
+All other non-blank lines must begin with a letter, dollar sign ("$"), or the percent sign ("%") as follows:
+.TP 5
+$name=value
+Sets the named variable to \fIvalue\fR.
+\fBNote:\fR Variables set in the list file are overridden by variables specified on the command-line or in the current environment.
+.TP 5
+%arch all
+Uses following files and directives on all processor architectures.
+.TP 5
+%arch \fIarchitecture [... architecture]\fR
+Uses following files and directives on the named processor architectures.
+.TP 5
+%arch !\fIarchitecture [... architecture]\fR
+Uses following files and directives on all but the named processor
+architectures.
+.TP 5
+%copyright \fIcopyright notice\fR
+Sets the copyright notice for the file.
+.TP 5
+%description \fIdescription text\fR
+Adds a line of descriptive text to the distribution. Multiple lines are
+supported.
+.TP 5
+%format \fIformat [... format]\fR
+Uses following files and directives only if the distribution format is the same as \fIformat\fR.
+.TP 5
+%format !\fIformat [... format]\fR
+Uses following files and directives only if the distribution format is not the same as \fIformat\fR.
+.TP 5
+%if \fIvariable\fR [... variable]\fR
+.TP 5
+%if !\fIvariable\fR [... variable]\fR
+.TP 5
+%ifdef \fIvariable\fR [... variable]\fR
+.TP 5
+%ifdef !\fIvariable\fR [... variable]\fR
+.TP 5
+%elseif \fIvariable\fR [... variable]\fR
+.TP 5
+%elseif !\fIvariable\fR [... variable]\fR
+.TP 5
+%elseifdef \fIvariable\fR [... variable]\fR
+.TP 5
+%elseifdef !\fIvariable\fR [... variable]\fR
+.TP 5
+%else
+.TP 5
+%endif
+Conditionally includes lines in the list file.
+The \fI%if\fR lines include the lines that follow if the named variables are (not) defined with a value.
+The \fI%ifdef\fR lines include the lines that follow if the named variables are (not) defined with any value.
+These conditional lines cannot be nested.
+.TP 5
+%include \fIfilename\fR
+Includes files listed in \fIfilename\fR.
+.TP 5
+%incompat \fIproduct\fR
+.TP 5
+%incompat \fIfilename\fR
+Indicates that this product is incompatible with the named product or file.
+.TP 5
+%install \fIscript or program\fR
+Specifies a script or program to be run after all files are installed.
+(This has been obsoleted by the %postinstall directive)
+.TP 5
+%license \fIlicense file\fR
+Specifies the file to display as the software license.
+.TP 5
+%literal(section) \fIline\fR
+.TP 5
+%literal(section) <\fIfile\fR
+.TP 5
+%literal(section) <<\fIstring\fR
+Specifies format-specific literal data for packaging.
+Currently only supported for RPM and PKG packages.
+.TP 5
+%packager \fIname of packager\fR
+Specifies the name of the packager.
+.TP 5
+%patch \fIscript or program\fR
+Specifies a script or program to be run after all files are patched.
+(This has been obsoleted by the %postpatch directive)
+.TP 5
+%postinstall \fIscript or program\fR
+.TP 5
+%postinstall <\fIscriptfile\fR
+.TP 5
+%postinstall <<\fIstring\fR
+Specifies a script or program to be run after all files are installed.
+.TP 5
+%postpatch \fIscript or program\fR
+.TP 5
+%postpatch <\fIscriptfile\fR
+.TP 5
+%postpatch <<\fIstring\fR
+Specifies a script or program to be run after all files are patched.
+.TP 5
+%postremove \fIscript or program\fR
+.TP 5
+%postremove <\fIscriptfile\fR
+.TP 5
+%postremove <<\fIstring\fR
+Specifies a script or program to be run after removing files.
+.TP 5
+%preinstall \fIscript or program\fR
+.TP 5
+%preinstall <\fIscriptfile\fR
+.TP 5
+%preinstall <<\fIstring\fR
+Specifies a script or program to be run before all files are installed.
+.TP 5
+%prepatch \fIscript or program\fR
+.TP 5
+%prepatch <\fIscriptfile\fR
+.TP 5
+%prepatch <<\fIstring\fR
+Specifies a script or program to be run before all files are patched.
+.TP 5
+%preremove \fIscript or program\fR
+.TP 5
+%preremove <\fIscriptfile\fR
+.TP 5
+%preremove <<\fIstring\fR
+Specifies a script or program to be run before removing files.
+.TP 5
+%product \fIproduct name\fR
+Specifies the product name.
+.TP 5
+%readme \fIreadme file\fR
+Specifies a README file to be included in the distribution.
+.TP 5
+%remove \fIscript or program\fR
+Specifies a script or program to be run before removing files.
+(This has been obsoleted by the %preremove directive)
+.TP 5
+%release \fInumber\fR
+Specifies the release or build number of a product (defaults to 0).
+.TP 5
+%replaces \fIproduct\fR
+Indicates that this product replaces the named product.
+.TP 5
+%requires \fIproduct\fR
+.TP 5
+%requires \fIfilename\fR
+Indicates that this product requires the named product or file.
+.TP 5
+%subpackage
+.TP 5
+%subpackage \fIname\fR
+Selects the named subpackage; if no name is given, selects the main (parent) package.
+.TP 5
+%vendor \fIvendor or author name\fR
+Specifies the vendor or author of the product.
+.TP 5
+%version \fIversion number\fR
+Specifies the version number of the product.
+.TP 5
+%system \fIsystem[-release] [... system[-release]]\fR
+Specifies that the following files should only be used for the specified operating systems and releases.
+.TP 5
+%system !\fIsystem[-release] [... system[-release]]\fR
+Specifies that the following files should not be used for the specified operating systems and releases.
+.TP 5
+%system all
+Specifies that the following files are applicable to all operating systems.
+.TP 5
+c \fImode user group destination source\fR
+.TP 5
+C \fImode user group destination source\fR
+Specifies a configuration file for installation.
+The second form specifies that the file has changed or is new and should be included as part of a patch.
+Configuration files are installed as "destination.N" if the destination already exists.
+.TP 5
+d \fImode user group destination -\fR
+.TP 5
+D \fImode user group destination -\fR
+Specifies a directory should be created when installing the software.
+The second form specifies that the directory is new and should be included as part of a patch.
+.TP 5
+f \fImode user group destination source [nostrip()]\fR
+.TP 5
+F \fImode user group destination source [nostrip()]\fR
+Specifies a file for installation.
+The second form specifies that the file has changed or is new and should be included as part of a patch.
+If the "nostrip()" option is included, the file will not be stripped before the installation is created.
+.TP 5
+f \fImode user group destination source/pattern [nostrip()]\fR
+.TP 5
+F \fImode user group destination source/pattern [nostrip()]\fR
+Specifies one or more files for installation using shell wildcard patterns.
+The second form specifies that the files have changed or are new and should be included as part of a patch.
+If the "nostrip()" option is included, the file will not be stripped before the installation is created.
+.TP 5
+i \fImode user group service-name source ["options"]\fR
+.TP 5
+I \fImode user group service-name source ["options"]\fR
+Specifies an initialization script for installation.
+The second form specifies that the file has changed or is new and should be included as part of a patch.
+Initialization scripts are stored in /etc/software/init.d and are linked to the appropriate system-specific directories for run levels 0, 2, 3, and 5.
+Initialization scripts \fBmust\fR accept at least the \fIstart\fR and \fIstop\fR commands.
+The optional \fIoptions\fR following the source filename can be any of the following:
+.TP 10
+     order(\fIstring\fR)
+Specifies the relative startup order compared to the required and used system functions.
+Supported values include First, Early, None, Late, and Last (macOS only).
+.TP 10
+     provides(\fIname(s)\fR)
+Specifies names of system functions that are provided by this startup item (macOS only).
+.TP 10
+     requires(\fIname(s)\fR)
+Specifies names of system functions that are required by this startup item (macOS only).
+.TP 10
+     runlevel(\fIlevels\fR)
+Specifies the run levels to use.
+.TP 10
+     start(\fInumber\fR)
+Specifies the starting sequence number from 00 to 99.
+.TP 10
+     stop(\fInumber\fR)
+Specifies the ending sequence number from 00 to 99.
+.TP 10
+     uses(\fIname(s)\fR)
+Specifies names of system functions that are used by this startup
+item (macOS only).
+
+.TP 5
+l \fImode user group destination source\fR
+.TP 5
+L \fImode user group destination source\fR
+Specifies a symbolic link in the installation.
+The second form specifies that the link has changed or is new and should be included as part of a patch.
+.TP 5
+R \fImode user group destination\fR
+Specifies that the file is to be removed upon patching.
+The \fIuser\fR and \fIgroup\fR fields are ignored.
+The \fImode\fR field is only used to determine if a check should be made for a previous version of the file.
+.SH LIST VARIABLES
+\fIEPM\fR maintains a list of variables and their values which can be used to substitute values in the list file.
+These variables are imported from the current environment and taken from the command-line and list file as provided.
+Substitutions occur when the variable name is referenced with the dollar sign ($):
+.nf
+.br
+
+    %postinstall <<EOF
+    echo What is your name:
+    read $$name
+    Your name is $$name
+    EOF
+
+    f 0555 root sys ${bindir}/foo foo
+    f 0555 root sys $datadir/foo/foo.dat foo.dat
+.fi
+.LP
+Variable names can be surrounded by curley brackets (${name}) or alone ($name); without brackets the name is terminated by the first slash (/), dash (-), or whitespace.
+The dollar sign can be inserted using $$.
+.SH SEE ALSO
+.BR epm (1),
+.BR epminstall (1),
+.BR mkepmlist (1).
+.SH COPYRIGHT
+Copyright \[co] 1999-2017 by Michael R Sweet, All Rights Reserved.
+.LP
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+.LP
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
diff --git a/./epm/doc/epm.man b/./epm/doc/epm.man
new file mode 100644
index 0000000..86bf965
--- /dev/null
+++ b/./epm/doc/epm.man
@@ -0,0 +1,210 @@
+.\"
+.\" Manual page for the ESP Package Manager (EPM).
+.\"
+.\" Copyright 1999-2017 by Michael R Sweet
+.\" Copyright 1999-2008 by Easy Software Products, all rights reserved.
+.\"
+.\" This program is free software; you can redistribute it and/or modify
+.\" it under the terms of the GNU General Public License as published by
+.\" the Free Software Foundation; either version 2, or (at your option)
+.\" any later version.
+.\"
+.\" This program is distributed in the hope that it will be useful,
+.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
+.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+.\" GNU General Public License for more details.
+.\"
+.TH epm 1 "ESP Package Manager" "10 October 2017" "Michael R Sweet"
+.SH NAME
+epm \- create software packages.
+.SH SYNOPSIS
+.B epm
+[
+.B \-a
+.I architecture
+] [
+.B \-f
+.I format
+] [
+.B \-g
+] [
+.B \-k
+] [
+.B \-m
+.I name
+] [
+\fB\-n\fR[\fBmrs\fR] ] [
+.B \-s
+.I setup.ext
+] [
+.B \-\-depend
+] [
+.B \-\-help
+] [
+.B \-\-keep\-files
+] [
+.B \-\-output\-dir
+.I directory
+] [
+.B \-\-setup\-image
+.I setup.ext
+] [
+.B \-\-setup\-program
+.I /foo/bar/setup
+] [
+.B \-\-setup\-types
+.I setup.types
+] [
+.B \-\-uninstall\-program
+.I /foo/bar/uninst
+] [
+.B \-v
+] [
+.I name=value
+\...
+.I name=value
+]
+.I product
+[
+.I listfile
+]
+.SH DESCRIPTION
+.BR epm (1)
+generates software packages complete with installation, removal, and (if necessary) patch scripts.
+Unless otherwise specified, the files required for \fIproduct\fR are read from a file named "\fIproduct\fR.list".
+.SH OPTIONS
+The following options are recognized:
+.TP 5
+\fB\-a \fIarchitecture\fR
+Specifies the actual architecture for the software.
+Without this option the generic processor architecture is used ("intel", "sparc", "mips", etc.)
+.TP 5
+\fB\-f aix\fR
+Generate an AIX distribution suitable for installation on an AIX system.
+.TP 5
+\fB\-f bsd\fR
+Generate a BSD distribution suitable for installation on a FreeBSD, NetBSD, or OpenBSD system.
+.TP 5
+\fB\-f deb\fR
+Generate a Debian distribution suitable for installation on a Debian Linux system.
+.TP 5
+\fB\-f inst\fR
+.TP 5
+\fB\-f tardist\fR
+Generate an IRIX distribution suitable for installation on an system running IRIX.
+.TP 5
+\fB\-f lsb\fR
+.TP 5
+\fB\-f lsb\-signed\fR
+Generate RPM packages for LSB-conforming systems.
+The \fIlsb\-signed\fR format uses the GPG private key you have defined in the ~/.rpmmacros file.
+.TP 5
+\fB\-f native\fR
+Generate a native distribution.
+This uses \fIrpm\fR for Linux, \fIinst\fR for IRIX, \fIpkg\fR for Solaris, \fIswinstall\fR for HP-UX, \fIbsd\fR for FreeBSD, NetBSD, and OpenBSD, and \fIosx\fR for macOS.
+All other operating systems default to the \fIportable\fR format.
+.TP 5
+\fB\-f macos\fR
+.TP 5
+\fB\-f macos\-signed\fR
+Generate a macOS software package.
+The \fImacos\-signed\fR format uses the signing identity in the EPM_SIGNING_IDENTITY environment variable.
+.TP 5
+\fB\-f pkg\fR
+Generate an AT&T software package.
+These are used primarily under Solaris.
+.TP 5
+\fB\-f portable\fR
+Generate a portable distribution based on shell scripts and tar files.
+The resulting distribution is installed and removed the same way on all operating systems. [default]
+.TP 5
+\fB\-f rpm\fR
+.TP 5
+\fB\-f rpm\-signed\fR
+Generate a Red Hat Package Manager ("RPM") distribution suitable for installation on a Red Hat Linux system.
+The \fIrpm\-signed\fR format uses the GPG private key you have defined in the ~/.rpmmacros file.
+.TP 5
+\fB\-f setld\fR
+Generate a Tru64 (setld) software distribution.
+.TP 5
+\fB\-f slackware\fR
+Generate a Slackware Linux software distribution.
+.TP 5
+\fB\-f swinstall\fR
+.TP 5
+\fB\-f depot\fR
+Generate a HP-UX software distribution.
+.TP 5
+\fB\-g\fR
+Disable stripping of executable files in the distribution.
+.TP 5
+\fB\-k\fR
+Keep intermediate (spec, etc.) files used to create the distribution in the distribution directory.
+.TP 5
+\fB\-m \fIname\fR
+Specifies the platform name as a string.
+The default is to use the auto-generated name from the \fI\-n\fR option.
+.TP 5
+\fB\-n\fR[\fImrs\fR]
+Specifies the operating system and machine information that is included in the package name.
+Distributions normally are named "product-version-system-release-machine.ext" and "product-version-system-release-machine-patch.ext" for patch distributions.
+The "system-release-machine" information can be customized or eliminated using the appropriate trailing letters.
+Using \fI-n\fR by itself will remove the "system-release-machine" string from the filename entirely.
+The letter 'm' includes the architecture (machine).
+The letter 'r' includes the operating system version (release).
+The letter 's' includes the operating system name.
+.TP 5
+\fB\-s \fIsetup.ext\fR
+.TP 5
+\fB\-v\fR
+Increases the amount of information that is reported.
+Use multiple v's for more verbose output.
+.TP 5
+\fB\-\-depend\fR
+Lists the dependent (source) files for all files in the package.
+.TP 5
+\fB\-\-output\-dir \fIdirectory\fR
+Specifies the directory for output files.
+The default directory is based on the operating system, version, and architecture.
+.TP 5
+\fB\-\-setup\-image \fIsetup.ext\fR
+Include the ESP Software Wizard with the specified image file with the distribution.
+This option is currently only supported by portable distributions.
+.TP 5
+\fB\-\-setup\-program \fI/foo/bar/setup\fR
+Specifies the setup executable to use with the distribution.
+This option is currently only supported by portable distributions.
+.TP 5
+\fB\-\-setup\-types \fIsetup.types\fR
+.LP
+Specifies the \fIsetup.types\fR file to include with the distribution.
+This option is currently only supported by portable distributions.
+.TP 5
+\fB\-\-uninstall\-program \fI/foo/bar/uninst\fR
+Specifies the uninst executable to use with the distribution.
+This option is currently only supported by portable distributions.
+.SH ENVIRONMENT
+The following environment variables are supported by \fBepm\fR:
+.TP 5
+.B EPM_SIGNING_IDENTITY
+The common name that should be used when signing a package.
+.SH LIST FILES
+The EPM list file format is now described in the \fIepm.list(5)\fR
+man page.
+.SH SEE ALSO
+.BR epminstall (1),
+.BR mkepmlist (1),
+.BR epm.list (5),
+.BR setup (1).
+.SH COPYRIGHT
+Copyright \[co] 1999-2017 by Michael R Sweet, All Rights Reserved.
+.LP
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+.LP
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
diff --git a/./epm/doc/epminstall.man b/./epm/doc/epminstall.man
new file mode 100644
index 0000000..35d70ce
--- /dev/null
+++ b/./epm/doc/epminstall.man
@@ -0,0 +1,93 @@
+.\"
+.\" Manual page for the ESP Package Manager (EPM) install program.
+.\"
+.\" Copyright 1999-2017 by Michael R Sweet
+.\" Copyright 1999-2007 by Easy Software Products, all rights reserved.
+.\"
+.\" This program is free software; you can redistribute it and/or modify
+.\" it under the terms of the GNU General Public License as published by
+.\" the Free Software Foundation; either version 2, or (at your option)
+.\" any later version.
+.\"
+.\" This program is distributed in the hope that it will be useful,
+.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
+.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+.\" GNU General Public License for more details.
+.\"
+.TH epminstall 1 "ESP Package Manager" "3 October 2017" "Michael R Sweet"
+.SH NAME
+epminstall \- add a directory, file, or symlink to a list file.
+.SH SYNOPSIS
+.B epminstall
+[
+.I options
+]
+.I file1 file2 ... fileN directory
+.br
+.B epminstall
+[
+.I options
+]
+.I file1 file2
+.br
+.B epminstall
+[
+.I options
+]
+.B \-d
+.I directory1 directory2 ... directoryN
+.SH DESCRIPTION
+.B epminstall
+adds or replaces a directory, file, or symlink
+in a list file. The default list file is "epm.list" and can be
+overridden using the \fIEPMLIST\fR environment variable or the
+\fI--list-file\fR option.
+.LP
+Entries are either added to the end of the list file or replaced
+in-line. Comments, directives, and variable declarations in the
+list file are preserved.
+.SH OPTIONS
+.B epminstall
+recognizes the standard Berkeley
+.BR install (8)
+command options:
+.TP 5
+.B \-b
+Make a backup of existing files (ignored, default for \fBepm\fR.)
+.TP 5
+.B \-c
+BSD old compatibility mode (ignored.)
+.TP 5
+\fB\-g \fIgroup\fR
+Set the group owner of the file or directory to \fIgroup\fR.
+The default group is "sys".
+.TP 5
+\fB\-m \fImode\fR
+Set the permissions of the file or directory to \fImode\fR.
+The default permissions are 0755 for directories and executable files and 0644 for non-executable files.
+.TP 5
+\fB\-o \fIowner\fR
+Set the owner of the file or directory to \fIowner\fR.
+The default owner is "root".
+.TP 5
+.B \-s
+Strip the files (ignored, default for \fBepm\fR.)
+.TP 5
+\fB\-\-list\-file \fIfilename.list\fR
+Specify the list file to update.
+.SH SEE ALSO
+.BR epm(1),
+.BR mkepmlist(1),
+.BR epm.list (5).
+.SH COPYRIGHT
+Copyright \[co] 1999-2017 by Michael R Sweet, All Rights Reserved.
+.LP
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+.LP
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
diff --git a/./epm/doc/mkepmlist.man b/./epm/doc/mkepmlist.man
new file mode 100644
index 0000000..7f02b90
--- /dev/null
+++ b/./epm/doc/mkepmlist.man
@@ -0,0 +1,73 @@
+.\"
+.\" Manual page for the ESP Package Manager (EPM).
+.\"
+.\" Copyright 1999-2017 by Michael R Sweet
+.\" Copyright 1999-2007 by Easy Software Products, all rights reserved.
+.\"
+.\" This program is free software; you can redistribute it and/or modify
+.\" it under the terms of the GNU General Public License as published by
+.\" the Free Software Foundation; either version 2, or (at your option)
+.\" any later version.
+.\"
+.\" This program is distributed in the hope that it will be useful,
+.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
+.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+.\" GNU General Public License for more details.
+.\"
+.TH mkepmlist 1 "ESP Package Manager" "3 October 2017" "Michael R Sweet"
+.SH NAME
+mkepmlist \- make an epm list file from a directory.
+.SH SYNOPSIS
+.B mkepmlist
+[
+.B \-g
+.I group
+] [
+.B \-u
+.I user
+] [
+.B \-\-prefix
+.I directory
+]
+.I directory
+[ ...
+.I directory
+]
+.SH DESCRIPTION
+.B mkepmlist (1)
+recursively generates file list entries for files, links, and directories.
+The file list is send to the standard output.
+.SH OPTIONS
+.B mkepmlist
+supports the following options:
+.TP 5
+\fB\-g \fIgroup\fR
+Overrides the group ownership of the files in the specified directories with the specified group name.
+.TP 5
+\fB\-u \fIuser\fR
+Overrides the user ownership of the files in the specified directories with the specified user name.
+.TP 5
+\fB\-\-prefix \fIdirectory\fR
+Adds the specified directory to the destination path.
+For example, if you installed files to "/opt/foo" and wanted to build a distribution that installed the files in "/usr/local", the following command would generate a file
+list that is installed in "/usr/local":
+.nf
+.br
+     mkepmlist \-\-prefix=/usr/local /opt/foo >foo.list
+.fi
+.SH SEE ALSO
+.BR epm (1),
+.BR epminstall (1),
+.BR epm.list (5).
+.SH COPYRIGHT
+Copyright \[co] 1999-2017 by Michael R Sweet, All Rights Reserved.
+.LP
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+.LP
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
diff --git a/tmp/epm/doc/preface.html b/./epm/doc/preface.html
index 693586c..c04016f 100644
--- a/tmp/epm/doc/preface.html
+++ b/./epm/doc/preface.html
@@ -121,11 +121,21 @@
 	<DD>Debian Developers' Corner
 	<BR>&nbsp;</DD>
 
+	<DT><A HREF="http://techpubs.sgi.com/">http://techpubs.sgi.com/</A></DT>
+
+	<DD>IRIX Documentation On-Line
+	<BR>&nbsp;</DD>
+
 	<DT><A HREF="http://www.rpm.org/">http://www.rpm.org/</A></DT>
 
 	<DD>The Red Hat Package Manager home page.
 	<BR>&nbsp;</DD>
 
+	<DT><A HREF="http://docs.sun.com/">http://docs.sun.com/</A></DT>
+
+	<DD>Solaris Documentation On-Line
+	<BR>&nbsp;</DD>
+
 </DL>
 
 <H2>Help Me Improve This Book!</H2>
diff --git a/./epm/doc/setup.man b/./epm/doc/setup.man
new file mode 100644
index 0000000..bba4e02
--- /dev/null
+++ b/./epm/doc/setup.man
@@ -0,0 +1,53 @@
+.\"
+.\" Manual page for the ESP Package Manager (EPM) setup GUI.
+.\"
+.\" Copyright 1999-2017 by Michael R Sweet
+.\" Copyright 1999-2007 by Easy Software Products, all rights reserved.
+.\"
+.\" This program is free software; you can redistribute it and/or modify
+.\" it under the terms of the GNU General Public License as published by
+.\" the Free Software Foundation; either version 2, or (at your option)
+.\" any later version.
+.\"
+.\" This program is distributed in the hope that it will be useful,
+.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
+.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+.\" GNU General Public License for more details.
+.\"
+.TH setup 1 "ESP Package Manager" "3 October 2017" "Michael R Sweet"
+.SH NAME
+setup \- graphical setup program for the esp package manager
+.SH SYNOPSIS
+.B setup
+[
+.I directory
+]
+.SH DESCRIPTION
+.BR setup (1)
+provides a graphical installation interface for EPM-generated portable installation packages.
+It presents a step-by-step dialog for collecting a list of packages to install and accepting any license agreements for those packages.
+.LP
+.B setup
+searches for products in the current directory or the directory specified on the command-line.
+.SH INSTALLATION TYPES
+The default type of installation is "custom".
+That is, users will be able to select from the list of products and install them.
+.LP
+.B setup
+also supports other types of installations.
+The \fIsetup.types\fR file, if present, defines the other installation types.
+.SH SEE ALSO
+.BR epm (1),
+.BR setup.types (5).
+.SH COPYRIGHT
+Copyright \[co] 1999-2017 by Michael R Sweet, All Rights Reserved.
+.LP
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+.LP
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
diff --git a/./epm/doc/setup.types.man b/./epm/doc/setup.types.man
new file mode 100644
index 0000000..829ae80
--- /dev/null
+++ b/./epm/doc/setup.types.man
@@ -0,0 +1,64 @@
+.\"
+.\" Manual page for the ESP Package Manager (EPM) setup types file format.
+.\"
+.\" Copyright 1999-2017 by Michael R Sweet
+.\" Copyright 1999-2007 by Easy Software Products, all rights reserved.
+.\"
+.\" This program is free software; you can redistribute it and/or modify
+.\" it under the terms of the GNU General Public License as published by
+.\" the Free Software Foundation; either version 2, or (at your option)
+.\" any later version.
+.\"
+.\" This program is distributed in the hope that it will be useful,
+.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
+.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+.\" GNU General Public License for more details.
+.\"
+.TH setup.types 5 "ESP Package Manager" "3 October 2017" "Michael R Sweet"
+.SH NAME
+setup.types \- epm gui setup types file format.
+.SH DESCRIPTION
+The EPM
+.BR setup (1)
+program normally presents the user with a list of software products to install, which is called a "custom" software installation.
+.LP
+If a file called \fIsetup.types\fR is present in the package directory, the user will instead be presented with a list of installation types.
+Each type has an associated product list which determines the products that are installed by default.
+If a type has no products associated with it, then it is treated as a custom installation and the user is presented with a list of packages to choose from.
+.SH FILE FORMAT
+The \fIsetup.types\fR file is an ASCII text file consisting of type and product lines.
+Comments can be inserted by starting a line with the pound sign (#).
+Each installation type is defined by a line starting with the word TYPE.
+Products are defined by a line starting with the word INSTALL:
+.in 5
+.nf
+
+TYPE Typical End-User Configuration
+INSTALL foo
+INSTALL foo-help
+TYPE Typical Developer Configuration
+INSTALL foo
+INSTALL foo-help
+INSTALL foo-devel
+INSTALL foo-examples
+TYPE Custom Configuration
+.fi
+.in
+.LP
+In the example above, three installation types are defined.
+Since the last type includes no products, the user will be presented with the full list of products to choose from.
+.SH SEE ALSO
+.BR epm (1),
+.BR setup (1).
+.SH COPYRIGHT
+Copyright \[co] 1999-2017 by Michael R Sweet, All Rights Reserved.
+.LP
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+.LP
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
diff --git a/tmp/epm/epm.c b/./epm/epm.c
index 2da9ea4..8b1657f 100644
--- a/tmp/epm/epm.c
+++ b/./epm/epm.c
@@ -70,14 +70,20 @@ main(int  argc,				/* I - Number of command-line args */
   static char	*formats[] =		/* Distribution format strings */
 		{
 		  "portable",
+		  "aix",
 		  "bsd",
 		  "deb",
+		  "inst",
 		  "rpm",
 		  "rpm",
 		  "macos",
 		  "macos",
+		  "pkg",
 		  "rpm",
-		  "rpm"
+		  "rpm",
+		  "setld",
+		  "slackware",
+		  "swinstall"
 		};
 
 
@@ -152,18 +158,36 @@ main(int  argc,				/* I - Number of command-line args */
 
 	    if (!strcasecmp(temp, "portable"))
 	      format = PACKAGE_PORTABLE;
+	    else if (!strcasecmp(temp, "aix"))
+	      format = PACKAGE_AIX;
 	    else if (!strcasecmp(temp, "bsd"))
 	      format = PACKAGE_BSD;
 	    else if (!strcasecmp(temp, "deb"))
 	      format = PACKAGE_DEB;
+	    else if (!strcasecmp(temp, "inst") ||
+	             !strcasecmp(temp, "tardist"))
+	      format = PACKAGE_INST;
+	    else if (!strcasecmp(temp, "lsb"))
+	      format = PACKAGE_LSB;
+	    else if (!strcasecmp(temp, "lsb-signed"))
+	      format = PACKAGE_LSB_SIGNED;
 	    else if (!strcasecmp(temp, "macos") || !strcasecmp(temp, "osx"))
 	      format = PACKAGE_MACOS;
 	    else if (!strcasecmp(temp, "macos-signed") || !strcasecmp(temp, "osx-signed"))
 	      format = PACKAGE_MACOS_SIGNED;
+	    else if (!strcasecmp(temp, "pkg"))
+	      format = PACKAGE_PKG;
 	    else if (!strcasecmp(temp, "rpm"))
 	      format = PACKAGE_RPM;
 	    else if (!strcasecmp(temp, "rpm-signed"))
 	      format = PACKAGE_RPM_SIGNED;
+	    else if (!strcasecmp(temp, "setld"))
+	      format = PACKAGE_SETLD;
+	    else if (!strcasecmp(temp, "slackware"))
+	      format = PACKAGE_SLACKWARE;
+	    else if (!strcasecmp(temp, "swinstall") ||
+	             !strcasecmp(temp, "depot"))
+	      format = PACKAGE_SWINSTALL;
 	    else if (!strcasecmp(temp, "native"))
 #if defined(__linux)
             {
@@ -176,8 +200,18 @@ main(int  argc,				/* I - Number of command-line args */
 	      else
 		format = PACKAGE_DEB;
             }
+#elif defined(__sgi)
+	      format = PACKAGE_INST;
+#elif defined(__osf__)
+	      format = PACKAGE_SETLD;
+#elif defined(__hpux)
+	      format = PACKAGE_SWINSTALL;
+#elif defined(_AIX)
+              format = PACKAGE_AIX;
 #elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
 	      format = PACKAGE_BSD;
+#elif defined(__svr4__) || defined(__SVR4) || defined(M_XENIX)
+	      format = PACKAGE_PKG;
 #elif defined(__APPLE__)
               format = PACKAGE_MACOS;
 #else
@@ -514,11 +548,15 @@ main(int  argc,				/* I - Number of command-line args */
         i = make_portable(prodname, directory, platname, dist, &platform,
 	                  setup, types);
 	break;
-
+    case PACKAGE_AIX :
+        i = make_aix(prodname, directory, platname, dist, &platform);
+	break;
     case PACKAGE_BSD :
         i = make_bsd(prodname, directory, platname, dist, &platform);
 	break;
-
+	case PACKAGE_SLACKWARE :
+        i = make_slackware(prodname, directory, platname, dist, &platform);
+	break;
     case PACKAGE_DEB :
         if (geteuid())
 	  fputs("epm: Warning - file permissions and ownership may not be correct\n"
@@ -526,17 +564,39 @@ main(int  argc,				/* I - Number of command-line args */
 
         i = make_deb(prodname, directory, platname, dist, &platform);
 	break;
-
+    case PACKAGE_INST :
+        i = make_inst(prodname, directory, platname, dist, &platform);
+	break;
     case PACKAGE_MACOS :
     case PACKAGE_MACOS_SIGNED :
         i = make_osx(format, prodname, directory, platname, dist, &platform, setup);
 	break;
-
+    case PACKAGE_PKG :
+        i = make_pkg(prodname, directory, platname, dist, &platform);
+	break;
+    case PACKAGE_LSB :
+    case PACKAGE_LSB_SIGNED :
     case PACKAGE_RPM :
     case PACKAGE_RPM_SIGNED :
         i = make_rpm(format, prodname, directory, platname, dist, &platform,
 	             setup, types);
 	break;
+    case PACKAGE_SETLD :
+        if (geteuid())
+	  fputs("epm: Warning - file permissions and ownership may not be correct\n"
+	        "     in Tru64 packages unless you run EPM as root!\n", stderr);
+
+        i = make_setld(prodname, directory, platname, dist, &platform);
+	break;
+    case PACKAGE_SWINSTALL :
+        if (geteuid())
+	{
+	  fputs("epm: Error - HP-UX packages must be built as root!\n", stderr);
+          i = 1;
+	}
+	else
+          i = make_swinstall(prodname, directory, platname, dist, &platform);
+	break;
   }
 
  /*
@@ -589,6 +649,10 @@ info(void)
 {
   puts(EPM_VERSION);
   puts("Copyright (c) 1999-2020 by Michael R Sweet.");
+#ifdef __FOR_AOO__
+  puts("Patched for Apache OpenOffice");
+  puts("  url: https://github.com/jimjag/epm/");
+#endif /* __FOR_AOO__ */
   puts("");
   puts("EPM is free software and comes with ABSOLUTELY NO WARRANTY; for details");
   puts("see the GNU General Public License in the file LICENSE or at");
@@ -613,7 +677,7 @@ usage(void)
   puts("    Use the named architecture instead of the local one.");
   puts("-g");
   puts("    Don't strip executables in distributions.");
-  puts("-f {bsd,deb,macos,macos-signed,native,portable,rpm,rpm-signed}");
+  puts("-f {aix,bsd,deb,depot,inst,macos,macos-signed,native,pkg,portable,rpm,rpm-signed,setld,slackware,swinstall,tardist}");
   puts("    Set distribution format.");
   puts("-k");
   puts("    Keep intermediate files (spec files, etc.)");
diff --git a/tmp/epm/epm.h b/./epm/epm.h
index 884d775..63f47f3 100644
--- a/tmp/epm/epm.h
+++ b/./epm/epm.h
@@ -94,12 +94,20 @@ extern "C" {
 enum
 {
   PACKAGE_PORTABLE,			/* Shell-script based EPM */
+  PACKAGE_AIX,				/* AIX package format */
   PACKAGE_BSD,				/* BSD package format */
   PACKAGE_DEB,				/* Debian package format */
+  PACKAGE_INST,				/* IRIX package format */
+  PACKAGE_LSB,				/* LSB (RPM) package format */
+  PACKAGE_LSB_SIGNED,			/* LSB (RPM) package format (signed) */
   PACKAGE_MACOS,			/* macOS package format */
   PACKAGE_MACOS_SIGNED,			/* macOS package format (signed) */
+  PACKAGE_PKG,				/* AT&T package format (AIX, Solaris) */
   PACKAGE_RPM,				/* RedHat package format */
-  PACKAGE_RPM_SIGNED			/* RedHat package format (signed) */
+  PACKAGE_RPM_SIGNED,			/* RedHat package format (signed) */
+  PACKAGE_SETLD,			/* Tru64 package format */
+  PACKAGE_SLACKWARE,			/* Slackware package format */
+  PACKAGE_SWINSTALL			/* HP-UX package format */
 };
 
 /*
@@ -261,6 +269,9 @@ extern const char *get_runlevels(file_t *file, const char *deflevels);
 extern int	get_start(file_t *file, int defstart);
 extern int	get_stop(file_t *file, int defstop);
 extern int	get_vernumber(const char *version);
+extern int	make_aix(const char *prodname, const char *directory,
+		         const char *platname, dist_t *dist,
+			 struct utsname *platform);
 extern int	make_bsd(const char *prodname, const char *directory,
 		         const char *platname, dist_t *dist,
 			 struct utsname *platform);
@@ -269,10 +280,16 @@ extern int	make_deb(const char *prodname, const char *directory,
 			 struct utsname *platform);
 extern int	make_directory(const char *directory, mode_t mode, uid_t owner,
 		               gid_t group);
+extern int	make_inst(const char *prodname, const char *directory,
+		          const char *platname, dist_t *dist,
+			  struct utsname *platform);
 extern int	make_link(const char *dst, const char *src);
 extern int	make_osx(int format, const char *prodname, const char *directory,
 		         const char *platname, dist_t *dist,
 			 struct utsname *platform, const char *setup);
+extern int	make_pkg(const char *prodname, const char *directory,
+		         const char *platname, dist_t *dist,
+			 struct utsname *platform);
 extern int	make_portable(const char *prodname, const char *directory,
 		              const char *platname, dist_t *dist,
 			      struct utsname *platform, const char *setup,
@@ -281,6 +298,15 @@ extern int	make_rpm(int format, const char *prodname, const char *directory,
 		         const char *platname, dist_t *dist,
 			 struct utsname *platform, const char *setup,
 			 const char *types);
+extern int	make_setld(const char *prodname, const char *directory,
+		           const char *platname, dist_t *dist,
+			   struct utsname *platform);
+extern int	make_slackware(const char *prodname, const char *directory,
+		               const char *platname, dist_t *dist,
+			       struct utsname *platform);
+extern int	make_swinstall(const char *prodname, const char *directory,
+		               const char *platname, dist_t *dist,
+			       struct utsname *platform);
 extern dist_t	*new_dist(void);
 extern int	qprintf(FILE *fp, const char *format, ...);
 extern dist_t	*read_dist(const char *filename, struct utsname *platform,
diff --git a/tmp/epm/file.c b/./epm/file.c
index 1cd53f0..0923d6a 100644
--- a/tmp/epm/file.c
+++ b/./epm/file.c
@@ -98,8 +98,10 @@ copy_file(const char *dst,		/* I - Destination file */
 
   if (mode)
     chmod(dst, mode);
+#ifndef __FOR_AOO__
   if (owner != (uid_t)-1 && group != (gid_t)-1)
     chown(dst, owner, group);
+#endif /* __FOR_AOO__ */
 
   return (0);
 }
@@ -130,8 +132,10 @@ make_directory(const char *directory,	/* I - Directory */
 	mkdir(buffer, 0755);
 	if (mode)
           chmod(buffer, mode | 0700);
+#ifndef __FOR_AOO__
 	if (owner != (uid_t)-1 && group != (gid_t)-1)
 	  chown(buffer, owner, group);
+#endif /* __FOR_AOO__ */
       }
     }
 
@@ -145,8 +149,10 @@ make_directory(const char *directory,	/* I - Directory */
     mkdir(buffer, 0755);
     if (mode)
       chmod(buffer, mode | 0700);
+#ifndef __FOR_AOO__
     if (owner != (uid_t)-1 && group != (gid_t)-1)
       chown(buffer, owner, group);
+#endif /* __FOR_AOO__ */
   }
 
   return (0);
diff --git a/tmp/epm/gui-common.h b/./epm/gui-common.h
index c79c6dd..ebacd7b 100644
--- a/tmp/epm/gui-common.h
+++ b/./epm/gui-common.h
@@ -22,11 +22,11 @@
 // Include necessary headers...
 //
 
-#  include "epmstring.h"
-#  include "epm.h"
-#  include <stdio.h>
-#  include <stdlib.h>
-#  include <FL/Fl_Help_View.H>
+#include "epmstring.h"
+#include "epm.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <FL/Fl_Help_View.H>
 
 
 //
@@ -77,11 +77,11 @@ typedef int (*compare_func_t)(const void *, const void *);
 // Globals...
 //
 
-#  ifdef _DEFINE_GLOBALS_
-#    define VAR
-#  else
-#    define VAR	extern
-#  endif // _DEFINE_GLOBALS_
+#ifdef _DEFINE_GLOBALS_
+#  define VAR
+#else
+#  define VAR	extern
+#endif // _DEFINE_GLOBALS_
 
 VAR int			NumDists;	// Number of distributions in directory
 VAR gui_dist_t		*Dists;		// Distributions in directory
diff --git a/./epm/inst.c b/./epm/inst.c
new file mode 100644
index 0000000..ec9e6e3
--- /dev/null
+++ b/./epm/inst.c
@@ -0,0 +1,681 @@
+/*
+ * IRIX package gateway for the ESP Package Manager (EPM).
+ *
+ * Copyright 1999-2017 by Michael R Sweet
+ * Copyright 1999-2006 by Easy Software Products.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "epm.h"
+
+
+/*
+ * Local functions...
+ */
+
+void	inst_subsys(FILE *fp, const char *prodname, dist_t *dist,
+		    const char *subpackage, const char *category,
+		    const char *section);
+
+
+/*
+ * 'make_inst()' - Make an IRIX software distribution package.
+ */
+
+int					/* O - 0 = success, 1 = fail */
+make_inst(const char     *prodname,	/* I - Product short name */
+          const char     *directory,	/* I - Directory for distribution files */
+          const char     *platname,	/* I - Platform name */
+          dist_t         *dist,		/* I - Distribution information */
+	  struct utsname *platform)	/* I - Platform information */
+{
+  int		i;			/* Looping var */
+  FILE		*fp;			/* Spec/IDB/script file */
+  tarf_t	*tarfile;		/* .tardist file */
+  char		name[1024];		/* Full product name */
+  char		specname[1024];		/* Spec filename */
+  char		idbname[1024];		/* IDB filename */
+  char		filename[1024],		/* Destination filename */
+		srcname[1024],		/* Name of source file in distribution */
+		dstname[1024];		/* Name of destination file in distribution */
+  char		preinstall[1024],	/* Pre install script */
+		postinstall[1024],	/* Post install script */
+		preremove[1024],	/* Pre remove script */
+		postremove[1024];	/* Post remove script */
+  char		subsys[255];		/* Subsystem name */
+  file_t	*file;			/* Current distribution file */
+  command_t	*c;			/* Current command */
+  struct stat	fileinfo;		/* File information */
+  const char	*runlevels;		/* Run levels */
+  static const char *extensions[] =	/* INST file extensions */
+		{
+		  "",
+		  ".idb",
+		  ".man",
+		  ".sw"
+		};
+
+
+  REF(platform);
+
+  if (Verbosity)
+    puts("Creating inst distribution...");
+
+  if (dist->release[0])
+  {
+    if (platname[0])
+      snprintf(name, sizeof(name), "%s-%s-%s-%s", prodname, dist->version, dist->release,
+              platname);
+    else
+      snprintf(name, sizeof(name), "%s-%s-%s", prodname, dist->version, dist->release);
+  }
+  else if (platname[0])
+    snprintf(name, sizeof(name), "%s-%s-%s", prodname, dist->version, platname);
+  else
+    snprintf(name, sizeof(name), "%s-%s", prodname, dist->version);
+
+ /*
+  * Write the spec file for gendist...
+  */
+
+  if (Verbosity)
+    puts("Creating spec file...");
+
+  snprintf(specname, sizeof(specname), "%s/spec", directory);
+
+  if ((fp = fopen(specname, "w")) == NULL)
+  {
+    fprintf(stderr, "epm: Unable to create spec file \"%s\": %s\n", specname,
+            strerror(errno));
+    return (1);
+  }
+
+  fprintf(fp, "product %s\n", prodname);
+  qprintf(fp, "	id \"%s, %s\"\n", dist->product, dist->version);
+
+  fputs("	image sw\n", fp);
+  qprintf(fp, "		id \"%s, Software, %s\"\n", dist->product,
+          dist->version);
+  fprintf(fp, "		version %d\n", dist->vernumber);
+
+  inst_subsys(fp, prodname, dist, NULL, "Software", "sw");
+  for (i = 0; i < dist->num_subpackages; i ++)
+    inst_subsys(fp, prodname, dist, dist->subpackages[i], "Software", "sw");
+
+  fputs("	endimage\n", fp);
+
+  fputs("	image man\n", fp);
+  qprintf(fp, "		id \"%s, Man Pages, %s\"\n", dist->product,
+          dist->version);
+  fprintf(fp, "		version %d\n", dist->vernumber);
+
+  inst_subsys(fp, prodname, dist, NULL, "Man Pages", "man");
+  for (i = 0; i < dist->num_subpackages; i ++)
+    inst_subsys(fp, prodname, dist, dist->subpackages[i], "Man Pages", "man");
+
+  fputs("	endimage\n", fp);
+
+  fputs("endproduct\n", fp);
+
+  fclose(fp);
+
+ /*
+  * Add symlinks for init scripts...
+  */
+
+  for (i = 0; i < dist->num_files; i ++)
+    if (tolower(dist->files[i].type) == 'i')
+    {
+     /*
+      * Make symlinks for all of the selected run levels...
+      */
+
+      for (runlevels = get_runlevels(dist->files + i, "02");
+           isdigit(*runlevels & 255);
+	   runlevels ++)
+      {
+	file = add_file(dist, dist->files[i].subpackage);
+	file->type = 'l';
+	file->mode = 0;
+	strlcpy(file->user, "root", sizeof(file->user));
+	strlcpy(file->group, "sys", sizeof(file->group));
+	snprintf(file->src, sizeof(file->src), "../init.d/%s",
+        	 dist->files[i].dst);
+
+        if (*runlevels == '0')
+	  snprintf(file->dst, sizeof(file->dst), "/etc/rc0.d/K%02d%s",
+        	   get_stop(dist->files + i, 0), dist->files[i].dst);
+        else
+	  snprintf(file->dst, sizeof(file->dst), "/etc/rc%c.d/S%02d%s",
+        	   *runlevels, get_start(dist->files + i, 99),
+		   dist->files[i].dst);
+      }
+
+     /*
+      * Then send the original file to /etc/init.d...
+      */
+
+      file = dist->files + i;
+
+      snprintf(filename, sizeof(filename), "/etc/init.d/%s", file->dst);
+      strlcpy(file->dst, filename, sizeof(file->dst));
+    }
+
+ /*
+  * Add preinstall script as needed...
+  */
+
+  for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+    if (c->type == COMMAND_PRE_INSTALL)
+      break;
+
+  if (i)
+  {
+   /*
+    * Add the preinstall script file to the list...
+    */
+
+    file = add_file(dist, NULL);
+    file->type = '1';
+    file->mode = 0555;
+    strlcpy(file->user, "root", sizeof(file->user));
+    strlcpy(file->group, "sys", sizeof(file->group));
+    snprintf(file->src, sizeof(file->src), "%s/%s.preinstall", directory,
+             prodname);
+    snprintf(file->dst, sizeof(file->dst), "%s/%s.preinstall", SoftwareDir,
+             prodname);
+
+   /*
+    * Then create the install script...
+    */
+
+    if (Verbosity)
+      puts("Creating preinstall script...");
+
+    snprintf(preinstall, sizeof(preinstall), "%s/%s.preinstall", directory, prodname);
+
+    if ((fp = fopen(preinstall, "w")) == NULL)
+    {
+      fprintf(stderr, "epm: Unable to create script file \"%s\": %s\n", preinstall,
+              strerror(errno));
+      return (1);
+    }
+
+    fchmod(fileno(fp), 0755);
+
+    fputs("#!/bin/sh\n", fp);
+    fputs("# " EPM_VERSION "\n", fp);
+
+    for (; i > 0; i --, c ++)
+      if (c->type == COMMAND_PRE_INSTALL)
+        fprintf(fp, "%s\n", c->command);
+
+    fclose(fp);
+  }
+  else
+    preinstall[0] = '\0';
+
+ /*
+  * Add postinstall script as needed...
+  */
+
+  for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+    if (c->type == COMMAND_POST_INSTALL)
+      break;
+
+  if (i)
+  {
+   /*
+    * Add the postinstall script file to the list...
+    */
+
+    file = add_file(dist, NULL);
+    file->type = '2';
+    file->mode = 0555;
+    strlcpy(file->user, "root", sizeof(file->user));
+    strlcpy(file->group, "sys", sizeof(file->group));
+    snprintf(file->src, sizeof(file->src), "%s/%s.postinstall", directory,
+             prodname);
+    snprintf(file->dst, sizeof(file->dst), "%s/%s.postinstall", SoftwareDir,
+             prodname);
+
+   /*
+    * Then create the install script...
+    */
+
+    if (Verbosity)
+      puts("Creating postinstall script...");
+
+    snprintf(postinstall, sizeof(postinstall), "%s/%s.postinstall", directory, prodname);
+
+    if ((fp = fopen(postinstall, "w")) == NULL)
+    {
+      fprintf(stderr, "epm: Unable to create script file \"%s\": %s\n", postinstall,
+              strerror(errno));
+      return (1);
+    }
+
+    fchmod(fileno(fp), 0755);
+
+    fputs("#!/bin/sh\n", fp);
+    fputs("# " EPM_VERSION "\n", fp);
+
+    for (; i > 0; i --, c ++)
+      if (c->type == COMMAND_POST_INSTALL)
+        fprintf(fp, "%s\n", c->command);
+
+    fclose(fp);
+  }
+  else
+    postinstall[0] = '\0';
+
+ /*
+  * Add preremove script as needed...
+  */
+
+  for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+    if (c->type == COMMAND_PRE_REMOVE)
+      break;
+
+  if (i)
+  {
+   /*
+    * Add the preremove script file to the list...
+    */
+
+    file = add_file(dist, NULL);
+    file->type = '3';
+    file->mode = 0555;
+    strlcpy(file->user, "root", sizeof(file->user));
+    strlcpy(file->group, "sys", sizeof(file->group));
+    snprintf(file->src, sizeof(file->src), "%s/%s.preremove", directory,
+             prodname);
+    snprintf(file->dst, sizeof(file->dst), "%s/%s.preremove", SoftwareDir,
+             prodname);
+
+   /*
+    * Then create the install script...
+    */
+
+    if (Verbosity)
+      puts("Creating preremove script...");
+
+    snprintf(preremove, sizeof(preremove), "%s/%s.preremove", directory, prodname);
+
+    if ((fp = fopen(preremove, "w")) == NULL)
+    {
+      fprintf(stderr, "epm: Unable to create script file \"%s\": %s\n", preremove,
+              strerror(errno));
+      return (1);
+    }
+
+    fchmod(fileno(fp), 0755);
+
+    fputs("#!/bin/sh\n", fp);
+    fputs("# " EPM_VERSION "\n", fp);
+
+    for (; i > 0; i --, c ++)
+      if (c->type == COMMAND_PRE_REMOVE)
+        fprintf(fp, "%s\n", c->command);
+
+    qprintf(fp, "/bin/rm -f %s.copy\n", file->dst);
+
+    fclose(fp);
+  }
+  else
+    preremove[0] = '\0';
+
+ /*
+  * Add postremove script as needed...
+  */
+
+  for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+    if (c->type == COMMAND_POST_REMOVE)
+      break;
+
+  if (i)
+  {
+   /*
+    * Add the postremove script file to the list...
+    */
+
+    file = add_file(dist, NULL);
+    file->type = '4';
+    file->mode = 0555;
+    strlcpy(file->user, "root", sizeof(file->user));
+    strlcpy(file->group, "sys", sizeof(file->group));
+    snprintf(file->src, sizeof(file->src), "%s/%s.postremove", directory,
+             prodname);
+    snprintf(file->dst, sizeof(file->dst), "%s/%s.postremove", SoftwareDir,
+             prodname);
+
+   /*
+    * Then create the remove script...
+    */
+
+    if (Verbosity)
+      puts("Creating postremove script...");
+
+    snprintf(postremove, sizeof(postremove), "%s/%s.postremove", directory, prodname);
+
+    if ((fp = fopen(postremove, "w")) == NULL)
+    {
+      fprintf(stderr, "epm: Unable to create script file \"%s\": %s\n", postremove,
+              strerror(errno));
+      return (1);
+    }
+
+    fchmod(fileno(fp), 0755);
+
+    fputs("#!/bin/sh\n", fp);
+    fputs("# " EPM_VERSION "\n", fp);
+
+    for (; i > 0; i --, c ++)
+      if (c->type == COMMAND_POST_REMOVE)
+        fprintf(fp, "%s\n", c->command);
+
+    qprintf(fp, "/bin/rm -f %s.copy\n", file->dst);
+
+    fclose(fp);
+  }
+  else
+    postremove[0] = '\0';
+
+ /*
+  * Sort the file list by the destination name, since gendist needs a sorted
+  * list...
+  */
+
+  sort_dist_files(dist);
+
+ /*
+  * Write the idb file for gendist...
+  */
+
+  if (Verbosity)
+    puts("Creating idb file...");
+
+  snprintf(idbname, sizeof(idbname), "%s/idb", directory);
+
+  if ((fp = fopen(idbname, "w")) == NULL)
+  {
+    fprintf(stderr, "epm: Unable to create idb file \"%s\": %s\n", idbname,
+            strerror(errno));
+    return (1);
+  }
+
+  for (i = dist->num_files, file = dist->files; i > 0; i --, file ++)
+  {
+    if (strstr(file->dst, "/man/") != NULL ||
+        strstr(file->dst, "/catman/") != NULL)
+      snprintf(subsys, sizeof(subsys), "%s.man.%s", prodname,
+               file->subpackage ? file->subpackage : "eoe");
+    else
+      snprintf(subsys, sizeof(subsys), "%s.sw.%s", prodname,
+               file->subpackage ? file->subpackage : "eoe");
+
+    switch (tolower(file->type))
+    {
+      case '1' :
+          qprintf(fp, "f %04o %s %s %s %s %s postop($rbase/%s)\n", file->mode,
+	          file->user, file->group, file->dst + 1, file->src, subsys,
+		  file->dst + 1);
+          break;
+      case '2' :
+          qprintf(fp, "f %04o %s %s %s %s %s exitop($rbase/%s)\n", file->mode,
+	          file->user, file->group, file->dst + 1, file->src, subsys,
+		  file->dst + 1);
+          break;
+      case '3' :
+      case '4' :
+          qprintf(fp, "f %04o %s %s %s %s %s "
+	              "postop(cp $rbase/%s $rbase/%s.copy) "
+		      "removeop($rbase/%s.copy; rm -f $rbase/%s.copy)\n",
+                  file->mode, file->user, file->group, file->dst + 1,
+		  file->src, subsys, file->dst + 1, file->dst + 1,
+		  file->dst + 1);
+          break;
+      case 'c' :
+          qprintf(fp, "f %04o %s %s %s %s %s config(suggest)\n", file->mode,
+	          file->user, file->group, file->dst + 1, file->src, subsys);
+          break;
+      case 'd' :
+          qprintf(fp, "d %04o %s %s %s - %s\n", file->mode,
+	          file->user, file->group, file->dst + 1, subsys);
+          break;
+      case 'f' :
+          qprintf(fp, "f %04o %s %s %s %s %s\n", file->mode,
+	          file->user, file->group, file->dst + 1, file->src, subsys);
+          break;
+      case 'i' :
+          qprintf(fp, "f %04o %s %s %s %s %s "
+	              "postop(cp $rbase/etc/init.d/%s $rbase/etc/init.d/%s.copy) "
+	              "exitop($rbase/etc/init.d/%s start) "
+		      "removeop($rbase/etc/init.d/%s.copy stop; rm -f $rbase/etc/init.d/%s.copy)\n",
+	          file->mode, file->user, file->group, file->dst + 1,
+		  file->src, subsys,
+		  file->dst + 12, file->dst + 12,
+		  file->dst + 12,
+		  file->dst + 12, file->dst + 12);
+          break;
+      case 'l' :
+          qprintf(fp, "l %04o %s %s %s - %s symval(%s)\n", file->mode,
+	          file->user, file->group, file->dst + 1, subsys, file->src);
+          break;
+    }
+  }
+
+  fclose(fp);
+
+ /*
+  * Build the distribution from the spec file...
+  */
+
+  if (Verbosity)
+    puts("Building INST binary distribution...");
+
+  if (run_command(NULL, "gendist %s -dist %s -sbase . -idb %s -spec %s",
+                  Verbosity == 0 ? "" : "-v", directory, idbname, specname))
+    return (1);
+
+ /*
+  * Build the tardist file...
+  */
+
+  if (Verbosity)
+    printf("Writing tardist file:");
+
+  snprintf(filename, sizeof(filename), "%s/%s.tardist", directory, name);
+  if ((tarfile = tar_open(filename, 0)) == NULL)
+  {
+    if (Verbosity)
+      puts("");
+
+    fprintf(stderr, "epm: Unable to create file \"%s\" -\n     %s\n",
+            filename, strerror(errno));
+    return (1);
+  }
+
+  for (i = 0; i < 4; i ++)
+  {
+    snprintf(srcname, sizeof(srcname), "%s/%s%s", directory, prodname, extensions[i]);
+    snprintf(dstname, sizeof(dstname), "%s%s", prodname, extensions[i]);
+
+    stat(srcname, &fileinfo);
+    if (tar_header(tarfile, TAR_NORMAL, fileinfo.st_mode, fileinfo.st_size,
+	           fileinfo.st_mtime, "root", "sys", dstname, NULL) < 0)
+      return (-1);
+
+    if (tar_file(tarfile, srcname) < 0)
+      return (-1);
+
+    if (Verbosity)
+    {
+      printf(" %s%s", prodname, extensions[i]);
+      fflush(stdout);
+    }
+  }
+
+  tar_close(tarfile);
+
+  if (Verbosity)
+  {
+    stat(filename, &fileinfo);
+    if (fileinfo.st_size > (1024 * 1024))
+      printf(" size=%.1fM\n", fileinfo.st_size / 1024.0 / 1024.0);
+    else
+      printf(" size=%.0fk\n", fileinfo.st_size / 1024.0);
+  }
+
+ /*
+  * Remove temporary files...
+  */
+
+  if (!KeepFiles)
+  {
+    if (Verbosity)
+      puts("Removing temporary distribution files...");
+
+    if (preinstall[0])
+      unlink(preinstall);
+    if (postinstall[0])
+      unlink(postinstall);
+    if (preremove[0])
+      unlink(preremove);
+    if (postremove[0])
+      unlink(postremove);
+
+    unlink(idbname);
+    unlink(specname);
+  }
+
+  return (0);
+}
+
+
+/*
+ * 'inst_subsys()' - Write a subsystem definition for the product.
+ */
+
+void
+inst_subsys(FILE       *fp,		/* I - File to write to */
+            const char *prodname,	/* I - Product short name */
+	    dist_t     *dist,		/* I - Distribution */
+	    const char *subpackage,	/* I - Subpackage name or NULL */
+	    const char *category,	/* I - "Software" or "Man Pages" */
+	    const char *section)	/* I - "sw" or "man" */
+{
+  int		i;			/* Looping var */
+  depend_t	*d;			/* Current dependency */
+  const char	*product;		/* Product for dependency */
+  char		selfname[1024];		/* Self product name */
+  char		title[1024];		/* Product description/title */
+
+
+  snprintf(selfname, sizeof(selfname), "%s.%s.eoe", prodname, section);
+
+  if (subpackage)
+  {
+    fprintf(fp, "		subsys %s\n", subpackage);
+
+    for (i = 0; i < dist->num_descriptions; i ++)
+      if (dist->descriptions[i].subpackage == subpackage)
+        break;
+
+    if (i < dist->num_descriptions)
+      snprintf(title, sizeof(title), "%s %s", dist->product,
+               dist->descriptions[i].description);
+    else
+      strlcpy(title, dist->product, sizeof(title));
+  }
+  else
+  {
+    fputs("		subsys eoe default\n", fp);
+
+    strlcpy(title, dist->product, sizeof(title));
+  }
+
+  qprintf(fp, "			id \"%s, %s, %s\"\n", title, category,
+          dist->version);
+  fprintf(fp, "			exp \"%s.%s.%s\"\n", prodname, section,
+          subpackage ? subpackage : "eoe");
+
+  for (i = dist->num_depends, d = dist->depends; i > 0; i --, d ++)
+    if (d->type == DEPEND_REQUIRES && d->subpackage == subpackage)
+      break;
+
+  if (i)
+  {
+    fputs("			prereq\n", fp);
+    fputs("			(\n", fp);
+    for (; i > 0; i --, d ++)
+      if (d->type == DEPEND_REQUIRES && d->subpackage == subpackage)
+      {
+	if (!strcmp(d->product, "_self"))
+          product = selfname;
+	else
+          product = d->product;
+
+        if (strchr(product, '.') != NULL)
+  	  fprintf(fp, "				%s %d %d\n",
+         	  product, d->vernumber[0], d->vernumber[1]);
+        else if (product[0] != '/')
+  	  fprintf(fp, "				%s.%s.* %d %d\n",
+         	  product, section, d->vernumber[0], d->vernumber[1]);
+      }
+    fputs("			)\n", fp);
+  }
+
+  for (i = dist->num_depends, d = dist->depends; i > 0; i --, d ++)
+    if (d->type == DEPEND_REPLACES && d->subpackage == subpackage)
+    {
+      if (!strcmp(d->product, "_self"))
+        product = selfname;
+      else
+        product = d->product;
+
+      if (strchr(product, '.') != NULL)
+      {
+        fprintf(fp, "			replaces %s %d %d\n",
+         	product, d->vernumber[0], d->vernumber[1]);
+        fprintf(fp, "			updates %s %d %d\n",
+         	product, d->vernumber[0], d->vernumber[1]);
+      }
+      else if (product[0] != '/')
+      {
+        fprintf(fp, "			replaces %s.%s.* %d %d\n",
+         	product, section, d->vernumber[0], d->vernumber[1]);
+        fprintf(fp, "			updates %s.%s.* %d %d\n",
+         	product, section, d->vernumber[0], d->vernumber[1]);
+      }
+    }
+    else if (d->type == DEPEND_INCOMPAT && d->subpackage == subpackage)
+    {
+      if (!strcmp(d->product, "_self"))
+        product = selfname;
+      else
+        product = d->product;
+
+      if (strchr(product, '.') != NULL)
+        fprintf(fp, "			incompat %s %d %d\n",
+         	product, d->vernumber[0], d->vernumber[1]);
+      else if (product[0] != '/')
+        fprintf(fp, "			incompat %s.%s.* %d %d\n",
+         	product, section, d->vernumber[0], d->vernumber[1]);
+    }
+
+  fputs("		endsubsys\n", fp);
+}
diff --git a/tmp/epm/makesrcdist b/./epm/makesrcdist
index 0542318..d34471a 100755
--- a/tmp/epm/makesrcdist
+++ b/./epm/makesrcdist
@@ -15,5 +15,4 @@ git tag -m "Tag $version" v$version
 git push origin v$version
 
 echo Creating epm-$version-source.tar.gz...
-git archive --format tar --prefix=epm-$version/ HEAD | gzip -v9 >epm-$version.tar.gz
-gpg --detach-sign epm-$version.tar.gz
+git archive --format tar HEAD | gzip -v9 >epm-$version-source.tar.gz
diff --git a/./epm/pkg.c b/./epm/pkg.c
new file mode 100644
index 0000000..b391678
--- /dev/null
+++ b/./epm/pkg.c
@@ -0,0 +1,573 @@
+/*
+ * AT&T package gateway for the ESP Package Manager (EPM).
+ *
+ * Copyright 1999-2017 by Michael R Sweet
+ * Copyright 1999-2010 by Easy Software Products.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "epm.h"
+
+
+/*
+ * Local functions...
+ */
+
+static const char	*pkg_path(const char *filename, const char *dirname);
+
+
+/*
+ * 'make_pkg()' - Make an AT&T software distribution package.
+ */
+
+int					/* O - 0 = success, 1 = fail */
+make_pkg(const char     *prodname,	/* I - Product short name */
+         const char     *directory,	/* I - Directory for distribution files */
+         const char     *platname,	/* I - Platform name */
+         dist_t         *dist,		/* I - Distribution information */
+	 struct utsname *platform)	/* I - Platform information */
+{
+  int		i;			/* Looping var */
+  FILE		*fp;			/* Control file */
+  char		name[1024];		/* Full product name */
+  char		filename[1024],		/* Destination filename */
+		preinstall[1024],	/* Pre install script */
+		postinstall[1024],	/* Post install script */
+		preremove[1024],	/* Pre remove script */
+		postremove[1024],	/* Post remove script */
+		request[1024];		/* Request script */
+  char		current[1024];		/* Current directory */
+  file_t	*file;			/* Current distribution file */
+  command_t	*c;			/* Current command */
+  depend_t	*d;			/* Current dependency */
+  tarf_t	*tarfile;		/* Distribution file */
+  time_t	curtime;		/* Current time info */
+  struct tm	*curdate;		/* Current date info */
+  const char	*runlevels;		/* Run levels */
+
+
+  if (Verbosity)
+    puts("Creating PKG distribution...");
+
+  if (dist->release[0])
+  {
+    if (platname[0])
+      snprintf(name, sizeof(name), "%s-%s-%s-%s", prodname, dist->version, dist->release,
+              platname);
+    else
+      snprintf(name, sizeof(name), "%s-%s-%s", prodname, dist->version, dist->release);
+  }
+  else if (platname[0])
+    snprintf(name, sizeof(name), "%s-%s-%s", prodname, dist->version, platname);
+  else
+    snprintf(name, sizeof(name), "%s-%s", prodname, dist->version);
+
+  getcwd(current, sizeof(current));
+
+ /*
+  * Write the pkginfo file for pkgmk...
+  */
+
+  if (Verbosity)
+    puts("Creating package information file...");
+
+  snprintf(filename, sizeof(filename), "%s/%s.pkginfo", directory, prodname);
+
+  if ((fp = fopen(filename, "w")) == NULL)
+  {
+    fprintf(stderr, "epm: Unable to create package information file \"%s\": %s\n", filename, strerror(errno));
+    return (1);
+  }
+
+  curtime = time(NULL);
+  curdate = gmtime(&curtime);
+
+  fprintf(fp, "PKG=%s\n", prodname);
+  fprintf(fp, "NAME=%s\n", dist->product);
+  fprintf(fp, "VERSION=%s\n", dist->version);
+  fprintf(fp, "VENDOR=%s\n", dist->vendor);
+  fprintf(fp, "PSTAMP=epm%04d%02d%02d%02d%02d%02d\n",
+          curdate->tm_year + 1900, curdate->tm_mon + 1, curdate->tm_mday,
+	  curdate->tm_hour, curdate->tm_min, curdate->tm_sec);
+
+  if (dist->num_descriptions > 0)
+    fprintf(fp, "DESC=%s\n", dist->descriptions[0].description);
+
+  fputs("CATEGORY=application\n", fp);
+  fputs("CLASSES=none", fp);
+  for (i = 0; i < dist->num_subpackages; i ++)
+    fprintf(fp, " %s", dist->subpackages[i]);
+  putc('\n', fp);
+
+  if (strcmp(platform->machine, "intel") == 0)
+    fputs("ARCH=i86pc\n", fp);
+  else
+    fputs("ARCH=sparc\n", fp);
+
+  fclose(fp);
+
+ /*
+  * Write the depend file for pkgmk...
+  */
+
+  if (Verbosity)
+    puts("Creating package dependency file...");
+
+  snprintf(filename, sizeof(filename), "%s/%s.depend", directory, prodname);
+
+  if ((fp = fopen(filename, "w")) == NULL)
+  {
+    fprintf(stderr, "epm: Unable to create package dependency file \"%s\": %s\n", filename, strerror(errno));
+    return (1);
+  }
+
+  for (i = dist->num_depends, d = dist->depends; i > 0; i --, d ++)
+    if (!strcmp(d->product, "_self"))
+      continue;
+    else if (d->type == DEPEND_REQUIRES)
+      fprintf(fp, "P %s\n", d->product);
+    else
+      fprintf(fp, "I %s\n", d->product);
+
+  fclose(fp);
+
+ /*
+  * Write the preinstall file for pkgmk...
+  */
+
+  for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+    if (c->type == COMMAND_PRE_INSTALL)
+      break;
+
+  if (i)
+  {
+   /*
+    * Write the preinstall file for pkgmk...
+    */
+
+    if (Verbosity)
+      puts("Creating preinstall script...");
+
+    snprintf(preinstall, sizeof(preinstall), "%s/%s.preinstall", directory,
+             prodname);
+
+    if ((fp = fopen(preinstall, "w")) == NULL)
+    {
+      fprintf(stderr, "epm: Unable to create script file \"%s\": %s\n", preinstall, strerror(errno));
+      return (1);
+    }
+
+    fchmod(fileno(fp), 0755);
+
+    fputs("#!/bin/sh\n", fp);
+    fputs("# " EPM_VERSION "\n", fp);
+
+    for (; i > 0; i --, c ++)
+      if (c->type == COMMAND_PRE_INSTALL)
+        fprintf(fp, "%s\n", c->command);
+
+    fclose(fp);
+  }
+  else
+    preinstall[0] = '\0';
+
+ /*
+  * Write the postinstall file for pkgmk...
+  */
+
+  for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+    if (c->type == COMMAND_POST_INSTALL)
+      break;
+
+  if (!i)
+    for (i = dist->num_files, file = dist->files; i > 0; i --, file ++)
+      if (tolower(file->type) == 'i')
+        break;
+
+  if (i)
+  {
+   /*
+    * Write the postinstall file for pkgmk...
+    */
+
+    if (Verbosity)
+      puts("Creating postinstall script...");
+
+    snprintf(postinstall, sizeof(postinstall), "%s/%s.postinstall", directory,
+             prodname);
+
+    if ((fp = fopen(postinstall, "w")) == NULL)
+    {
+      fprintf(stderr, "epm: Unable to create script file \"%s\": %s\n", postinstall, strerror(errno));
+      return (1);
+    }
+
+    fchmod(fileno(fp), 0755);
+
+    fputs("#!/bin/sh\n", fp);
+    fputs("# " EPM_VERSION "\n", fp);
+
+    for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+      if (c->type == COMMAND_POST_INSTALL)
+        fprintf(fp, "%s\n", c->command);
+
+    for (i = dist->num_files, file = dist->files; i > 0; i --, file ++)
+      if (tolower(file->type) == 'i')
+	qprintf(fp, "/etc/init.d/%s start\n", file->dst);
+
+    fclose(fp);
+  }
+  else
+    postinstall[0] = '\0';
+
+ /*
+  * Write the preremove script...
+  */
+
+  for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+    if (c->type == COMMAND_PRE_REMOVE)
+      break;
+
+  if (!i)
+    for (i = dist->num_files, file = dist->files; i > 0; i --, file ++)
+      if (tolower(file->type) == 'i')
+        break;
+
+  if (i)
+  {
+   /*
+    * Write the preremove file for pkgmk...
+    */
+
+    if (Verbosity)
+      puts("Creating preremove script...");
+
+    snprintf(preremove, sizeof(preremove), "%s/%s.preremove", directory, prodname);
+
+    if ((fp = fopen(preremove, "w")) == NULL)
+    {
+      fprintf(stderr, "epm: Unable to create script file \"%s\": %s\n", preremove, strerror(errno));
+      return (1);
+    }
+
+    fchmod(fileno(fp), 0755);
+
+    fputs("#!/bin/sh\n", fp);
+    fputs("# " EPM_VERSION "\n", fp);
+
+    for (i = dist->num_files, file = dist->files; i > 0; i --, file ++)
+      if (tolower(file->type) == 'i')
+	qprintf(fp, "/etc/init.d/%s stop\n", file->dst);
+
+    for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+      if (c->type == COMMAND_PRE_REMOVE)
+        fprintf(fp, "%s\n", c->command);
+
+    fclose(fp);
+  }
+  else
+    preremove[0] = '\0';
+
+ /*
+  * Write the postremove file for pkgmk...
+  */
+
+  for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+    if (c->type == COMMAND_POST_REMOVE)
+      break;
+
+  if (i)
+  {
+   /*
+    * Write the postremove file for pkgmk...
+    */
+
+    if (Verbosity)
+      puts("Creating postremove script...");
+
+    snprintf(postremove, sizeof(postremove), "%s/%s.postremove", directory,
+             prodname);
+
+    if ((fp = fopen(postremove, "w")) == NULL)
+    {
+      fprintf(stderr, "epm: Unable to create script file \"%s\": %s\n", postremove, strerror(errno));
+      return (1);
+    }
+
+    fchmod(fileno(fp), 0755);
+
+    fputs("#!/bin/sh\n", fp);
+    fputs("# " EPM_VERSION "\n", fp);
+
+    for (; i > 0; i --, c ++)
+      if (c->type == COMMAND_POST_REMOVE)
+        fprintf(fp, "%s\n", c->command);
+
+    fclose(fp);
+  }
+  else
+    postremove[0] = '\0';
+
+ /*
+  * Write the request file for pkgmk...
+  */
+
+  for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+    if (c->type == COMMAND_LITERAL && !strcmp(c->section, "request"))
+      break;
+
+  if (i)
+  {
+   /*
+    * Write the request file for pkgmk...
+    */
+
+    if (Verbosity)
+      puts("Creating request script...");
+
+    snprintf(request, sizeof(request), "%s/%s.request", directory,
+             prodname);
+
+    if ((fp = fopen(request, "w")) == NULL)
+    {
+      fprintf(stderr, "epm: Unable to create script file \"%s\": %s\n", request, strerror(errno));
+      return (1);
+    }
+
+    fchmod(fileno(fp), 0755);
+
+    fputs("#!/bin/sh\n", fp);
+    fputs("# " EPM_VERSION "\n", fp);
+
+    for (; i > 0; i --, c ++)
+      if (c->type == COMMAND_LITERAL && !strcmp(c->section, "request"))
+        fprintf(fp, "%s\n", c->command);
+
+    fclose(fp);
+  }
+  else
+    request[0] = '\0';
+
+ /*
+  * Add symlinks for init scripts...
+  */
+
+  for (i = 0; i < dist->num_files; i ++)
+    if (tolower(dist->files[i].type) == 'i')
+    {
+     /*
+      * Make symlinks for all of the selected run levels...
+      */
+
+      for (runlevels = get_runlevels(dist->files + i, "023");
+           isdigit(*runlevels & 255);
+	   runlevels ++)
+      {
+	file = add_file(dist, dist->files[i].subpackage);
+	file->type = 'l';
+	file->mode = 0;
+	strlcpy(file->user, "root", sizeof(file->user));
+	strlcpy(file->group, "sys", sizeof(file->group));
+	snprintf(file->src, sizeof(file->src), "../init.d/%s",
+        	 dist->files[i].dst);
+
+        if (*runlevels == '0')
+	  snprintf(file->dst, sizeof(file->dst), "/etc/rc0.d/K%02d%s",
+        	   get_stop(dist->files + i, 0), dist->files[i].dst);
+        else
+	  snprintf(file->dst, sizeof(file->dst), "/etc/rc%c.d/S%02d%s",
+        	   *runlevels, get_start(dist->files + i, 99),
+		   dist->files[i].dst);
+      }
+
+     /*
+      * Then send the original file to /etc/init.d...
+      */
+
+      file = dist->files + i;
+
+      snprintf(filename, sizeof(filename), "/etc/init.d/%s", file->dst);
+      strlcpy(file->dst, filename, sizeof(file->dst));
+    }
+
+ /*
+  * Write the prototype file for pkgmk...
+  */
+
+  if (Verbosity)
+    puts("Creating prototype file...");
+
+  snprintf(filename, sizeof(filename), "%s/%s.prototype", directory, prodname);
+
+  if ((fp = fopen(filename, "w")) == NULL)
+  {
+    fprintf(stderr, "epm: Unable to create prototype file \"%s\": %s\n", filename, strerror(errno));
+    return (1);
+  }
+
+  if (dist->license[0])
+    fprintf(fp, "i copyright=%s\n", pkg_path(dist->license, current));
+  fprintf(fp, "i depend=%s/%s.depend\n", pkg_path(directory, current), prodname);
+  fprintf(fp, "i pkginfo=%s/%s.pkginfo\n", pkg_path(directory, current),
+          prodname);
+
+  if (preinstall[0])
+    fprintf(fp, "i preinstall=%s\n", pkg_path(preinstall, current));
+  if (postinstall[0])
+    fprintf(fp, "i postinstall=%s\n", pkg_path(postinstall, current));
+  if (preremove[0])
+    fprintf(fp, "i preremove=%s\n", pkg_path(preremove, current));
+  if (postremove[0])
+    fprintf(fp, "i postremove=%s\n", pkg_path(postremove, current));
+  if (request[0])
+    fprintf(fp, "i request=%s\n", pkg_path(request, current));
+
+  for (i = dist->num_files, file = dist->files; i > 0; i --, file ++)
+    switch (tolower(file->type))
+    {
+      case 'c' :
+          qprintf(fp, "e %s %s=%s %04o %s %s\n",
+	          file->subpackage ? file->subpackage : "none",
+	          file->dst, pkg_path(file->src, current),
+		  file->mode, file->user, file->group);
+          break;
+      case 'd' :
+	  qprintf(fp, "d %s %s %04o %s %s\n",
+	          file->subpackage ? file->subpackage : "none",
+	          file->dst, file->mode, file->user, file->group);
+          break;
+      case 'f' :
+      case 'i' :
+          qprintf(fp, "f %s %s=%s %04o %s %s\n",
+	          file->subpackage ? file->subpackage : "none",
+	          file->dst, pkg_path(file->src, current),
+		  file->mode, file->user, file->group);
+          break;
+      case 'l' :
+          qprintf(fp, "s %s %s=%s\n",
+	          file->subpackage ? file->subpackage : "none",
+	          file->dst, file->src);
+          break;
+    }
+
+  fclose(fp);
+
+#ifndef __FOR_AOO__
+ /*
+  * Build the distribution from the prototype file...
+  */
+
+  if (Verbosity)
+    puts("Building PKG binary distribution...");
+
+  if (run_command(NULL, "pkgmk -o -f %s/%s.prototype -d %s/%s",
+                  directory, prodname, current, directory))
+    return (1);
+
+ /*
+  * Tar and compress the distribution...
+  */
+
+  if (Verbosity)
+    puts("Creating .pkg.tgz file for distribution...");
+
+  snprintf(filename, sizeof(filename), "%s/%s.pkg.tgz", directory, name);
+
+  if ((tarfile = tar_open(filename, 1)) == NULL)
+    return (1);
+
+  snprintf(filename, sizeof(filename), "%s/%s", directory, prodname);
+
+  if (tar_directory(tarfile, filename, prodname))
+  {
+    tar_close(tarfile);
+    return (1);
+  }
+
+  tar_close(tarfile);
+
+ /*
+  * Make a package stream file...
+  */
+
+  if (Verbosity)
+    puts("Copying into package stream file...");
+
+  if (run_command(directory, "pkgtrans -s %s/%s %s.pkg %s",
+                  current, directory, name, prodname))
+    return (1);
+
+ /*
+  * Compress the package stream file...
+  */
+
+  snprintf(filename, sizeof(filename), "%s.pkg.gz", name);
+  unlink(filename);
+
+  if (run_command(directory, EPM_GZIP " -vf9 %s.pkg", name))
+    return (1);
+
+ /*
+  * Remove temporary files...
+  */
+
+  if (!KeepFiles)
+  {
+    if (Verbosity)
+      puts("Removing temporary distribution files...");
+
+    snprintf(filename, sizeof(filename), "%s/%s.pkginfo", directory, prodname);
+    unlink(filename);
+    snprintf(filename, sizeof(filename), "%s/%s.depend", directory, prodname);
+    unlink(filename);
+    snprintf(filename, sizeof(filename), "%s/%s.prototype", directory, prodname);
+    unlink(filename);
+    if (preinstall[0])
+      unlink(preinstall);
+    if (postinstall[0])
+      unlink(postinstall);
+    if (preremove[0])
+      unlink(preremove);
+    if (postremove[0])
+      unlink(postremove);
+    if (request[0])
+      unlink(request);
+
+    snprintf(filename, sizeof(filename), "%s/%s", directory, prodname);
+    unlink_directory(filename);
+  }
+#endif /* __FOR_AOO__ */
+  return (0);
+}
+
+
+/*
+ * 'pkg_path()' - Return an absolute path for the prototype file.
+ */
+
+static const char *			/* O - Absolute filename */
+pkg_path(const char *filename,		/* I - Source filename */
+         const char *dirname)		/* I - Source directory */
+{
+  static char	absname[1024];		/* Absolute filename */
+
+
+  if (filename[0] == '/')
+    return (filename);
+
+  snprintf(absname, sizeof(absname), "%s/%s", dirname, filename);
+  return (absname);
+}
diff --git a/tmp/epm/qprintf.c b/./epm/qprintf.c
index acb8c35..c8eb2a8 100644
--- a/tmp/epm/qprintf.c
+++ b/./epm/qprintf.c
@@ -173,12 +173,15 @@ qprintf(FILE       *fp,		/* I - File to write to */
 
             for (i = slen; i > 0; i --, s ++, bytes ++)
 	    {
+#if defined(__FreeBSD__) && defined(__FOR_AOO__)
+	      if (strchr("`~!#%^&*()[{]}\\|;\'\"<>? ", *s))
+#else
 	      if (strchr("`~#$%^&*()[{]}\\|;\'\"<>? ", *s))
+#endif
 	      {
 	        putc('\\', fp);
 		bytes ++;
 	      }
-
 	      putc(*s, fp);
 	    }
 
diff --git a/tmp/epm/rpm.c b/./epm/rpm.c
index 1e9efbf..7dd89d9 100644
--- a/tmp/epm/rpm.c
+++ b/./epm/rpm.c
@@ -20,6 +20,7 @@
  */
 
 #include "epm.h"
+#include <stdbool.h>
 
 
 /*
@@ -106,6 +107,9 @@ make_rpm(int            format,		/* I - Subformat */
   fprintf(fp, "Packager: %s\n", dist->packager);
   fprintf(fp, "Vendor: %s\n", dist->vendor);
 
+  if (format == PACKAGE_LSB || format == PACKAGE_LSB_SIGNED)
+    fputs("Requires: lsb >= 3.0\n", fp);
+
  /*
   * Tell RPM to put the distributions in the output directory...
   */
@@ -185,7 +189,12 @@ make_rpm(int            format,		/* I - Subformat */
 	    return (1);
           break;
       case 'i' :
-	  snprintf(filename, sizeof(filename), "%s/buildroot%s/init.d/%s", directory, SoftwareDir, file->dst);
+          if (format == PACKAGE_LSB || format == PACKAGE_LSB_SIGNED)
+	    snprintf(filename, sizeof(filename), "%s/buildroot/etc/init.d/%s",
+		     directory, file->dst);
+          else
+	    snprintf(filename, sizeof(filename), "%s/buildroot%s/init.d/%s",
+		     directory, SoftwareDir, file->dst);
 
 	  if (Verbosity > 1)
 	    printf("%s -> %s...\n", file->src, filename);
@@ -212,6 +221,7 @@ make_rpm(int            format,		/* I - Subformat */
     }
   }
 
+#ifndef __FOR_AOO__
  /*
   * Build the distribution from the spec file...
   */
@@ -219,26 +229,30 @@ make_rpm(int            format,		/* I - Subformat */
   if (Verbosity)
     puts("Building RPM binary distribution...");
 
-  if (format == PACKAGE_RPM_SIGNED)
+  if (format == PACKAGE_LSB_SIGNED || format == PACKAGE_RPM_SIGNED)
     build_option = "-signed ";
   else
     build_option = "";
+  
+  bool use_new_rpm = false;
+  if( access( "/usr/bin/rpmbuild", F_OK ) == -1 )
+    use_new_rpm = true;
 
   if (!strcmp(platform->machine, "intel"))
   {
-    if (run_command(NULL, EPM_RPMBUILD " -bb --buildroot \"%s/buildroot\" "
+    if (run_command(NULL, use_new_rpm ? EPM_RPMBUILD : EPM_RPMBUILD_NEW " -bb --buildroot \"%s/buildroot\" "
                           EPM_RPMARCH "i386 %s%s", absdir, build_option,
 			  specname))
       return (1);
   }
   else if (!strcmp(platform->machine, "ppc"))
   {
-    if (run_command(NULL, EPM_RPMBUILD " -bb --buildroot \"%s/buildroot\" "
+    if (run_command(NULL, use_new_rpm ? EPM_RPMBUILD : EPM_RPMBUILD_NEW " -bb --buildroot \"%s/buildroot\" "
                           EPM_RPMARCH "ppc %s%s", absdir, build_option,
 			  specname))
       return (1);
   }
-  else if (run_command(NULL, EPM_RPMBUILD " -bb --buildroot \"%s/buildroot\" "
+  else if (run_command(NULL, use_new_rpm ? EPM_RPMBUILD : EPM_RPMBUILD_NEW " -bb --buildroot \"%s/buildroot\" "
                        EPM_RPMARCH "%s %s%s", absdir, platform->machine,
 		       build_option, specname))
     return (1);
@@ -465,7 +479,7 @@ make_rpm(int            format,		/* I - Subformat */
                        dist->subpackages[i]);
     }
   }
-
+#endif
   return (0);
 }
 
@@ -705,59 +719,75 @@ write_spec(int        format,		/* I - Subformat */
     fputs("if test \"x$1\" = x1; then\n", fp);
     fputs("	echo Setting up init scripts...\n", fp);
 
-   /*
-    * Find where the frigging init scripts go...
-    */
-
-    fputs("	rcdir=\"\"\n", fp);
-    fputs("	for dir in /sbin/rc.d /sbin /etc/rc.d /etc ; do\n", fp);
-    fputs("		if test -d $dir/rc3.d -o -h $dir/rc3.d; then\n", fp);
-    fputs("			rcdir=\"$dir\"\n", fp);
-    fputs("		fi\n", fp);
-    fputs("	done\n", fp);
-    fputs("	if test \"$rcdir\" = \"\" ; then\n", fp);
-    fputs("		echo Unable to determine location of startup scripts!\n", fp);
-    fputs("	else\n", fp);
-    for (; i > 0; i --, file ++)
+    if (format == PACKAGE_LSB)
     {
-      if (tolower(file->type) == 'i' && file->subpackage == subpackage)
-      {
-	fputs("		if test -d $rcdir/init.d; then\n", fp);
-	qprintf(fp, "			/bin/rm -f $rcdir/init.d/%s\n", file->dst);
-	qprintf(fp, "			/bin/ln -s %s/init.d/%s "
-		    "$rcdir/init.d/%s\n", SoftwareDir, file->dst, file->dst);
-	fputs("		else\n", fp);
-	fputs("			if test -d /etc/init.d; then\n", fp);
-	qprintf(fp, "				/bin/rm -f /etc/init.d/%s\n", file->dst);
-	qprintf(fp, "				/bin/ln -s %s/init.d/%s "
-		    "/etc/init.d/%s\n", SoftwareDir, file->dst, file->dst);
-	fputs("			fi\n", fp);
-	fputs("		fi\n", fp);
-
-	for (runlevels = get_runlevels(dist->files + i, "0123456");
-	     isdigit(*runlevels & 255);
-	     runlevels ++)
+     /*
+      * Use LSB commands to install the init scripts...
+      */
+
+      for (; i > 0; i --, file ++)
+	if (tolower(file->type) == 'i' && file->subpackage == subpackage)
 	{
-	  if (*runlevels == '0')
-	    number = get_stop(file, 0);
-	  else
-	    number = get_start(file, 99);
-
-	  qprintf(fp, "		/bin/rm -f $rcdir/rc%c.d/%c%02d%s\n", *runlevels,
-		  (*runlevels == '0' || *runlevels == '1' ||
-		   *runlevels == '6') ? 'K' : 'S', number, file->dst);
-	  qprintf(fp, "		/bin/ln -s %s/init.d/%s "
-		      "$rcdir/rc%c.d/%c%02d%s\n", SoftwareDir, file->dst,
-		  *runlevels,
-		  (*runlevels == '0' || *runlevels == '1' ||
-		   *runlevels == '6') ? 'K' : 'S', number, file->dst);
+	  fprintf(fp, "	/usr/lib/lsb/install_initd /etc/init.d/%s\n", file->dst);
+	  fprintf(fp, "	/etc/init.d/%s start\n", file->dst);
 	}
+    }
+    else
+    {
+     /*
+      * Find where the frigging init scripts go...
+      */
 
-	qprintf(fp, "		%s/init.d/%s start\n", SoftwareDir, file->dst);
-      }
+      fputs("	rcdir=\"\"\n", fp);
+      fputs("	for dir in /sbin/rc.d /sbin /etc/rc.d /etc ; do\n", fp);
+      fputs("		if test -d $dir/rc3.d -o -h $dir/rc3.d; then\n", fp);
+      fputs("			rcdir=\"$dir\"\n", fp);
+      fputs("		fi\n", fp);
+      fputs("	done\n", fp);
+      fputs("	if test \"$rcdir\" = \"\" ; then\n", fp);
+      fputs("		echo Unable to determine location of startup scripts!\n", fp);
+      fputs("	else\n", fp);
+      for (; i > 0; i --, file ++)
+    {
+	if (tolower(file->type) == 'i' && file->subpackage == subpackage)
+	{
+	  fputs("		if test -d $rcdir/init.d; then\n", fp);
+	  qprintf(fp, "			/bin/rm -f $rcdir/init.d/%s\n", file->dst);
+	  qprintf(fp, "			/bin/ln -s %s/init.d/%s "
+		      "$rcdir/init.d/%s\n", SoftwareDir, file->dst, file->dst);
+	  fputs("		else\n", fp);
+	  fputs("			if test -d /etc/init.d; then\n", fp);
+	  qprintf(fp, "				/bin/rm -f /etc/init.d/%s\n", file->dst);
+	  qprintf(fp, "				/bin/ln -s %s/init.d/%s "
+		      "/etc/init.d/%s\n", SoftwareDir, file->dst, file->dst);
+	  fputs("			fi\n", fp);
+	  fputs("		fi\n", fp);
+
+	  for (runlevels = get_runlevels(dist->files + i, "0123456");
+	       isdigit(*runlevels & 255);
+	       runlevels ++)
+	  {
+	    if (*runlevels == '0')
+	      number = get_stop(file, 0);
+	    else
+	      number = get_start(file, 99);
+
+	    qprintf(fp, "		/bin/rm -f $rcdir/rc%c.d/%c%02d%s\n", *runlevels,
+		    (*runlevels == '0' || *runlevels == '1' ||
+		     *runlevels == '6') ? 'K' : 'S', number, file->dst);
+	    qprintf(fp, "		/bin/ln -s %s/init.d/%s "
+			"$rcdir/rc%c.d/%c%02d%s\n", SoftwareDir, file->dst,
+		    *runlevels,
+		    (*runlevels == '0' || *runlevels == '1' ||
+		     *runlevels == '6') ? 'K' : 'S', number, file->dst);
+	  }
+
+	  qprintf(fp, "		%s/init.d/%s start\n", SoftwareDir, file->dst);
+	}
     }
 
-    fputs("	fi\n", fp);
+      fputs("	fi\n", fp);
+    }
 
     fputs("fi\n", fp);
   }
@@ -774,50 +804,66 @@ write_spec(int        format,		/* I - Subformat */
     fputs("if test \"x$1\" = x0; then\n", fp);
     fputs("	echo Cleaning up init scripts...\n", fp);
 
-   /*
-    * Find where the frigging init scripts go...
-    */
+    if (format == PACKAGE_LSB)
+    {
+     /*
+      * Use LSB commands to remove the init scripts...
+      */
 
-    fputs("	rcdir=\"\"\n", fp);
-    fputs("	for dir in /sbin/rc.d /sbin /etc/rc.d /etc ; do\n", fp);
-    fputs("		if test -d $dir/rc3.d -o -h $dir/rc3.d; then\n", fp);
-    fputs("			rcdir=\"$dir\"\n", fp);
-    fputs("		fi\n", fp);
-    fputs("	done\n", fp);
-    fputs("	if test \"$rcdir\" = \"\" ; then\n", fp);
-    fputs("		echo Unable to determine location of startup scripts!\n", fp);
-    fputs("	else\n", fp);
-    for (; i > 0; i --, file ++)
+      for (; i > 0; i --, file ++)
+	if (tolower(file->type) == 'i' && file->subpackage == subpackage)
+	{
+	  fprintf(fp, "	/etc/init.d/%s stop\n", file->dst);
+	  fprintf(fp, "	/usr/lib/lsb/remove_initd /etc/init.d/%s\n", file->dst);
+	}
+    }
+    else
     {
-      if (tolower(file->type) == 'i' && file->subpackage == subpackage)
-      {
-	qprintf(fp, "		%s/init.d/%s stop\n", SoftwareDir, file->dst);
-
-	fputs("		if test -d $rcdir/init.d; then\n", fp);
-	qprintf(fp, "			/bin/rm -f $rcdir/init.d/%s\n", file->dst);
-	fputs("		else\n", fp);
-	fputs("			if test -d /etc/init.d; then\n", fp);
-	qprintf(fp, "				/bin/rm -f /etc/init.d/%s\n", file->dst);
-	fputs("			fi\n", fp);
-	fputs("		fi\n", fp);
-
-	for (runlevels = get_runlevels(dist->files + i, "0123456");
-	     isdigit(*runlevels & 255);
-	     runlevels ++)
+     /*
+      * Find where the frigging init scripts go...
+      */
+
+      fputs("	rcdir=\"\"\n", fp);
+      fputs("	for dir in /sbin/rc.d /sbin /etc/rc.d /etc ; do\n", fp);
+      fputs("		if test -d $dir/rc3.d -o -h $dir/rc3.d; then\n", fp);
+      fputs("			rcdir=\"$dir\"\n", fp);
+      fputs("		fi\n", fp);
+      fputs("	done\n", fp);
+      fputs("	if test \"$rcdir\" = \"\" ; then\n", fp);
+      fputs("		echo Unable to determine location of startup scripts!\n", fp);
+      fputs("	else\n", fp);
+      for (; i > 0; i --, file ++)
+    {
+	if (tolower(file->type) == 'i' && file->subpackage == subpackage)
 	{
-	  if (*runlevels == '0')
-	    number = get_stop(file, 0);
-	  else
-	    number = get_start(file, 99);
-
-	  qprintf(fp, "		/bin/rm -f $rcdir/rc%c.d/%c%02d%s\n", *runlevels,
-		  (*runlevels == '0' || *runlevels == '1' ||
-		   *runlevels == '6') ? 'K' : 'S', number, file->dst);
+	  qprintf(fp, "		%s/init.d/%s stop\n", SoftwareDir, file->dst);
+
+	  fputs("		if test -d $rcdir/init.d; then\n", fp);
+	  qprintf(fp, "			/bin/rm -f $rcdir/init.d/%s\n", file->dst);
+	  fputs("		else\n", fp);
+	  fputs("			if test -d /etc/init.d; then\n", fp);
+	  qprintf(fp, "				/bin/rm -f /etc/init.d/%s\n", file->dst);
+	  fputs("			fi\n", fp);
+	  fputs("		fi\n", fp);
+
+	  for (runlevels = get_runlevels(dist->files + i, "0123456");
+	       isdigit(*runlevels & 255);
+	       runlevels ++)
+	  {
+	    if (*runlevels == '0')
+	      number = get_stop(file, 0);
+	    else
+	      number = get_start(file, 99);
+
+	    qprintf(fp, "		/bin/rm -f $rcdir/rc%c.d/%c%02d%s\n", *runlevels,
+		    (*runlevels == '0' || *runlevels == '1' ||
+		     *runlevels == '6') ? 'K' : 'S', number, file->dst);
+	  }
 	}
-      }
     }
 
-    fputs("	fi\n", fp);
+      fputs("	fi\n", fp);
+    }
 
     fputs("fi\n", fp);
   }
@@ -890,7 +936,12 @@ write_spec(int        format,		/* I - Subformat */
 	            file->group, file->dst);
             break;
 	case 'i' :
-	    fprintf(fp, "%%attr(0555,root,root) \"%s/init.d/%s\"\n", SoftwareDir, file->dst);
+	    if (format == PACKAGE_LSB)
+	      fprintf(fp, "%%attr(0555,root,root) \"/etc/init.d/%s\"\n",
+		      file->dst);
+            else
+	      fprintf(fp, "%%attr(0555,root,root) \"%s/init.d/%s\"\n",
+	              SoftwareDir, file->dst);
             break;
       }
 
diff --git a/./epm/setld.c b/./epm/setld.c
new file mode 100644
index 0000000..ac399f7
--- /dev/null
+++ b/./epm/setld.c
@@ -0,0 +1,456 @@
+/*
+ * Tru64 package gateway for the ESP Package Manager (EPM)
+ *
+ * Copyright 2001-2017 by Michael R Sweet
+ * Copyright 2001-2010 by Easy Software Products
+ * Copyright 2001 by Aneesh Kumar (aneesh.kumar@digital.com) at Digital India.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "epm.h"
+
+
+/*
+ * 'make_setld()' - Make a Tru64 setld package.
+ */
+
+int					/* O - 0 = success, 1 = fail */
+make_setld(const char     *prodname,	/* I - Product short name */
+           const char     *directory,	/* I - Directory for distribution files */
+           const char     *platname,	/* I - Platform name */
+           dist_t         *dist,	/* I - Distribution information */
+           struct utsname *platform)	/* I - Platform information */
+{
+  int		i, j;			/* Looping vars */
+  FILE		*fp;			/* Spec file */
+  tarf_t	*tarfile;		/* .tardist file */
+  char		name[1024];		/* Full product name */
+  char		scpname[1024];		/* XXXVVV control program filename */
+  char		miname[1024];		/* XXXVVV.mi filename */
+  char		keyname[1024];		/* XXXVVV.key filename */
+  char		filename[1024];		/* Destination filename */
+  char		subset[1024];		/* Subset name */
+  file_t	*file;			/* Current distribution file */
+  command_t	*c;			/* Current command */
+  char		current[1024];		/* Current directory */
+  struct passwd	*pwd;			/* Pointer to user record */
+  struct group	*grp;			/* Pointer to group record */
+  const char	*runlevels;		/* Run levels */
+
+
+  REF(platform);
+
+ /*
+  * Check the package information to make sure it complies with the
+  * extremely limited Tru64 packager requirements.
+  */
+
+  if (dist->vernumber < 100 || dist->vernumber > 999)
+  {
+    fprintf(stderr, "epm: Need a version number between 100 and 999 inclusive.\n"
+                    "     The current version number (%d) is out of range.\n",
+            dist->vernumber);
+    return (1);
+  }
+
+  if (strlen(prodname) < 3)
+  {
+    fprintf(stderr, "epm: Need a product name of at least 3 uppercase characters.\n"
+                    "     The current product name (%s) is not acceptable.\n",
+            prodname);
+    return (1);
+  }
+
+  for (i = 0; prodname[i]; i ++)
+    if (!isupper(prodname[i] & 255))
+    {
+      fprintf(stderr, "epm: Need a product name of at least 3 uppercase characters.\n"
+                      "     The current product name (%s) is not acceptable.\n",
+              prodname);
+      return (1);
+    }
+
+  for (i = 0; i < dist->num_subpackages; i ++)
+  {
+    if ((strlen(dist->subpackages[i]) + strlen(prodname)) > 77)
+    {
+      fprintf(stderr, "epm: Product + subpackage names must be less than 77 characters.\n"
+                      "     The current subpackage name (%s) is not acceptable.\n",
+              dist->subpackages[i]);
+      return (1);
+    }
+
+    for (j = 0; dist->subpackages[i][j]; j ++)
+      if (!isupper(dist->subpackages[i][j] & 255))
+      {
+	fprintf(stderr, "epm: Subpackage names may only contain uppercase letters.\n"
+                	"     The current subpackage name (%s) is not acceptable.\n",
+        	dist->subpackages[i]);
+	return (1);
+      }
+  }
+
+ /*
+  * Prepare for packaging...
+  */
+
+  if (dist->release[0])
+  {
+    if (platname[0])
+      snprintf(name, sizeof(name), "%s-%s-%s-%s", prodname, dist->version,
+               dist->release, platname);
+    else
+      snprintf(name, sizeof(name), "%s-%s-%s", prodname, dist->version,
+               dist->release);
+  }
+  else if (platname[0])
+    snprintf(name, sizeof(name), "%s-%s-%s", prodname, dist->version, platname);
+  else
+    snprintf(name, sizeof(name), "%s-%s", prodname, dist->version);
+
+  getcwd(current, sizeof(current));
+
+ /*
+  * Add symlinks for init scripts...
+  */
+
+  for (i = 0; i < dist->num_files; i ++)
+    if (tolower(dist->files[i].type) == 'i')
+    {
+     /*
+      * Make symlinks for all of the selected run levels...
+      */
+
+      for (runlevels = get_runlevels(dist->files + i, "023");
+           isdigit(*runlevels & 255);
+	   runlevels ++)
+      {
+	file = add_file(dist, dist->files[i].subpackage);
+	file->type = 'l';
+	file->mode = 0;
+	strlcpy(file->user, "root", sizeof(file->user));
+	strlcpy(file->group, "sys", sizeof(file->group));
+	snprintf(file->src, sizeof(file->src), "../init.d/%s",
+        	 dist->files[i].dst);
+
+        if (*runlevels == '0')
+	  snprintf(file->dst, sizeof(file->dst), "/sbin/rc0.d/K%02d%s",
+        	   get_stop(dist->files + i, 0), dist->files[i].dst);
+        else
+	  snprintf(file->dst, sizeof(file->dst), "/sbin/rc%c.d/S%02d%s",
+        	   *runlevels, get_start(dist->files + i, 99),
+		   dist->files[i].dst);
+      }
+
+     /*
+      * Then send the original file to /sbin/init.d...
+      */
+
+      file = dist->files + i;
+
+      snprintf(filename, sizeof(filename), "/sbin/init.d/%s", file->dst);
+      strlcpy(file->dst, filename, sizeof(file->dst));
+    }
+
+ /*
+  * Build package directories...
+  *
+  * Note: The src/scps directory and the key, inventory, and
+  *       subset control programs below should actually go in
+  *       a data subdirectory according to the Tru64
+  *       documentation, but (at least under 4.0d) the invcutter
+  *       program will not be able to find the distribution files
+  *       if they are not colocated with these data files.
+  */
+
+  if (Verbosity)
+    puts("Creating Tru64 (setld) distribution...");
+
+  snprintf(filename, sizeof(filename), "%s/output", directory);
+  unlink_directory(filename);
+
+  snprintf(filename, sizeof(filename), "%s/src", directory);
+  unlink_directory(filename);
+
+  snprintf(filename, sizeof(filename), "%s/output", directory);
+  mkdir(filename, 0777);
+
+  snprintf(filename, sizeof(filename), "%s/src", directory);
+  mkdir(filename, 0777);
+
+  snprintf(filename, sizeof(filename), "%s/src/scps", directory);
+  mkdir(filename, 0777);
+
+ /*
+  * Write the subset control program...
+  */
+
+  if (Verbosity)
+    puts("Creating subset control program...");
+
+  snprintf(scpname, sizeof(scpname), "%s/src/scps/%sALL%03d.scp", directory,
+           prodname, dist->vernumber);
+
+  if ((fp = fopen(scpname, "w")) == NULL)
+  {
+    fprintf(stderr, "epm: Unable to create subset control program \"%s\": %s\n", scpname, strerror(errno));
+    return (1);
+  }
+
+  fputs("#!/bin/sh\n", fp);
+  fputs("case $ACT in\n", fp);
+
+  fputs("PRE_L)\n", fp);
+  for (i = dist->num_files, file = dist->files; i > 0; i --, file ++)
+    if (tolower(file->type) == 'i')
+    {
+      qprintf(fp, "if test -x %s; then\n", file->dst);
+      qprintf(fp, "	%s stop\n", file->dst);
+      fputs("fi\n", fp);
+    }
+  for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+    if (c->type == COMMAND_PRE_INSTALL)
+      fprintf(fp, "%s\n", c->command);
+  fputs(";;\n", fp);
+
+  fputs("POST_L)\n", fp);
+  for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+    if (c->type == COMMAND_POST_INSTALL)
+      fprintf(fp, "%s\n", c->command);
+  for (i = dist->num_files, file = dist->files; i > 0; i --, file ++)
+    if (tolower(file->type) == 'c')
+    {
+      qprintf(fp, "if test ! -f %s; then\n", file->dst);
+      qprintf(fp, "	/bin/cp %s.N %s\n", file->dst, file->dst);
+      fputs("fi\n", fp);
+    }
+  for (i = dist->num_files, file = dist->files; i > 0; i --, file ++)
+    if (tolower(file->type) == 'i')
+      qprintf(fp, "%s start\n", file->dst);
+  fputs(";;\n", fp);
+
+  fputs("PRE_D)\n", fp);
+  for (i = dist->num_files, file = dist->files; i > 0; i --, file ++)
+    if (tolower(file->type) == 'i')
+      qprintf(fp, "%s stop\n", file->dst);
+  for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+    if (c->type == COMMAND_PRE_REMOVE)
+      fprintf(fp, "%s\n", c->command);
+  for (i = dist->num_files, file = dist->files; i > 0; i --, file ++)
+    if (tolower(file->type) == 'c')
+    {
+      qprintf(fp, "if cmp -s %s.N %s; then\n", file->dst, file->dst);
+      qprintf(fp, "	/bin/rm -f %s\n", file->dst);
+      fputs("fi\n", fp);
+    }
+  fputs(";;\n", fp);
+
+  fputs("POST_D)\n", fp);
+  for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+    if (c->type == COMMAND_POST_REMOVE)
+      fprintf(fp, "%s\n", c->command);
+  fputs(";;\n", fp);
+
+  fputs("esac\n", fp);
+
+  fclose(fp);
+
+ /*
+  * Sort the file list by the destination name, since kits need a sorted
+  * list...
+  */
+
+  sort_dist_files(dist);
+
+ /*
+  * Now do the inventory file...
+  */
+
+  if (Verbosity)
+    puts("Creating master inventory file...");
+
+  snprintf(miname, sizeof(miname), "%s/src/%s%03d.mi", directory, prodname, dist->vernumber);
+
+  if ((fp = fopen(miname, "w")) == NULL)
+  {
+    fprintf(stderr, "epm: Unable to create master inventory file \"%s\": %s\n", miname, strerror(errno));
+    return (1);
+  }
+
+  for (i = dist->num_files, file = dist->files; i > 0; i --, file ++)
+  {
+    snprintf(subset, sizeof(subset), "%s%s%03d", prodname,
+             file->subpackage ? file->subpackage : "ALL", dist->vernumber);
+
+    switch (tolower(file->type))
+    {
+      case 'c' :
+          fprintf(fp, "2\t.%s.N\t%s\n", file->dst, subset);
+	  break;
+      case 'd' :
+      case 'i' :
+      case 'f' :
+      case 'l' :
+          fprintf(fp, "0\t.%s\t%s\n", file->dst, subset);
+	  break;
+    }
+  }
+
+  fclose(fp);
+
+ /*
+  * Create the key file...
+  */
+
+  if (Verbosity)
+    puts("Creating key file...");
+
+  snprintf(keyname, sizeof(keyname), "%s/src/%s%03d.k", directory, prodname,
+           dist->vernumber);
+
+  if ((fp = fopen(keyname, "w")) == NULL)
+  {
+    fprintf(stderr, "epm: Unable to create key file \"%s\": %s\n", keyname, strerror(errno));
+    return (1);
+  }
+
+  qprintf(fp, "NAME='%s, %s'\n", dist->product, dist->version);
+  fprintf(fp, "CODE=%s\n", prodname);
+  fprintf(fp, "VER=%03d\n", dist->vernumber);
+  fprintf(fp, "MI=%s%03d.mi\n", prodname, dist->vernumber);
+  fputs("COMPRESS=0\n", fp);
+  fputs("%%\n", fp);
+  qprintf(fp, "%sALL%03d\t.\t0\t'%s, %s'\n", prodname, dist->vernumber,
+          dist->product, dist->version);
+  for (i = 0; i < dist->num_subpackages; i ++)
+    qprintf(fp, "%s%s%03d\t.\t0\t'%s, %s'\n", prodname, dist->subpackages[i],
+            dist->vernumber, dist->product, dist->version);
+  fclose(fp);
+
+ /*
+  * Copy the files over...
+  */
+
+  if (Verbosity)
+    puts("Copying temporary distribution files...");
+
+  for (i = dist->num_files, file = dist->files; i > 0; i --, file ++)
+  {
+   /*
+    * Find the username and groupname IDs...
+    */
+
+    pwd = getpwnam(file->user);
+    grp = getgrnam(file->group);
+
+    endpwent();
+    endgrent();
+
+   /*
+    * Copy the file or make the directory or make the symlink as needed...
+    */
+
+    switch (tolower(file->type))
+    {
+      case 'c' :
+      case 'f' :
+      case 'i' :
+          snprintf(filename, sizeof(filename), "%s/src%s", directory, file->dst);
+
+	  if (Verbosity > 1)
+	    printf("%s -> %s...\n", file->src, filename);
+
+	  if (copy_file(filename, file->src, file->mode, pwd ? pwd->pw_uid : 0,
+			grp ? grp->gr_gid : 0))
+	    return (1);
+          break;
+
+      case 'd' :
+          snprintf(filename, sizeof(filename), "%s/src%s", directory, file->dst);
+
+	  if (Verbosity > 1)
+	    printf("Directory %s...\n", filename);
+
+          make_directory(filename, file->mode, pwd ? pwd->pw_uid : 0,
+			 grp ? grp->gr_gid : 0);
+          break;
+
+      case 'l' :
+          snprintf(filename, sizeof(filename), "%s/src%s", directory, file->dst);
+
+	  if (Verbosity > 1)
+	    printf("%s -> %s...\n", file->src, filename);
+
+          make_link(filename, file->src);
+          break;
+    }
+  }
+
+ /*
+  * Build the distribution from the inventory and control files...
+  */
+
+  if (Verbosity)
+    puts("Building Tru64 (setld) distribution...");
+
+  snprintf(filename, sizeof(filename), "%s/src", directory);
+  chdir(filename);
+
+  if (run_command(NULL, "kits %s%03d.k . ../output", prodname, dist->vernumber))
+    return (1);
+
+  chdir(current);
+
+ /*
+  * Tar and compress the distribution...
+  */
+
+  if (Verbosity)
+    puts("Creating tar.gz file for distribution...");
+
+  snprintf(filename, sizeof(filename), "%s/%s.tar.gz", directory, name);
+
+  if ((tarfile = tar_open(filename, 1)) == NULL)
+    return (1);
+
+  snprintf(filename, sizeof(filename), "%s/output", directory);
+
+  if (tar_directory(tarfile, filename, prodname))
+  {
+    tar_close(tarfile);
+    return (1);
+  }
+
+  tar_close(tarfile);
+
+ /*
+  * Remove temporary files...
+  */
+
+  if (!KeepFiles)
+  {
+    if (Verbosity)
+      puts("Removing temporary distribution files...");
+
+    snprintf(filename, sizeof(filename), "%s/output", directory);
+    unlink_directory(filename);
+
+    snprintf(filename, sizeof(filename), "%s/src", directory);
+    unlink_directory(filename);
+  }
+
+  return (0);
+}
diff --git a/./epm/slackware.c b/./epm/slackware.c
new file mode 100644
index 0000000..7018cc1
--- /dev/null
+++ b/./epm/slackware.c
@@ -0,0 +1,320 @@
+/*
+ * Slackware package gateway for the ESP Package Manager (EPM).
+ *
+ * Copyright 2003-2017 by Michael R Sweet
+ * Copyright 2003-2010 by Easy Software Products.
+ *
+ * Contributed by Alec Thomas <$givenname at korn dot ch>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "epm.h"
+
+
+/*
+ * Local functions...
+ */
+
+static int	make_subpackage(const char *prodname, const char *directory,
+		                const char *platname, dist_t *dist,
+				const char *subpackage);
+
+
+/*
+ * 'make_slackware()' - Make a Slackware software distribution packages.
+ */
+
+int					/* O - 0 = success, 1 = fail */
+make_slackware(const char     *prodname,/* I - Product short name */
+	       const char     *directory,
+					/* I - Directory for distribution files */
+	       const char     *platname,/* I - Platform name */
+	       dist_t         *dist,	/* I - Distribution information */
+	       struct utsname *platform)/* I - Platform information */
+{
+  int		i;			/* Looping var */
+
+
+  REF(platform);
+
+ /*
+  * Check to see if we are being run as root...
+  */
+
+  if (getuid())
+  {
+    fprintf(stderr, "ERROR: Can only make Slackware packages as root\n");
+    return (1);
+  }
+
+ /*
+  * Create subpackages...
+  */
+
+  if (make_subpackage(prodname, directory, platname, dist, NULL))
+    return (1);
+
+  for (i = 0; i < dist->num_subpackages; i ++)
+    if (make_subpackage(prodname, directory, platname, dist,
+                        dist->subpackages[i]))
+      return (1);
+
+  return (0);
+}
+
+
+/*
+ * 'make_subpackage()' - Make a Slackware subpackage.
+ */
+
+static int				/* O - 0 = success, 1 = fail */
+make_subpackage(const char *prodname,	/* I - Product short name */
+	        const char *directory,	/* I - Directory for distribution files */
+	        const char *platname,	/* I - Platform name */
+	        dist_t     *dist,	/* I - Distribution information */
+	        const char *subpackage)	/* I - Subpackage name */
+{
+  int		i;			/* Looping var */
+  FILE		*fp;			/* Spec file */
+  char		prodfull[1024],		/* Full name of product */
+		filename[1024],		/* Destination filename */
+		pkgname[1024];		/* Package filename */
+  file_t	*file;			/* Current distribution file */
+  command_t	*c;			/* Current command */
+  struct passwd	*pwd;			/* Pointer to user record */
+  struct group	*grp;			/* Pointer to group record */
+  struct utsname platform;		/* Original platform data */
+
+
+ /*
+  * Figure out the full product name...
+  */
+
+  if (subpackage)
+    snprintf(prodfull, sizeof(prodfull), "%s-%s", prodname, subpackage);
+  else
+    strlcpy(prodfull, prodname, sizeof(prodfull));
+
+  if (Verbosity)
+    printf("Creating Slackware %s pkg distribution...\n", prodfull);
+
+ /*
+  * Slackware uses the real machine type in its package names...
+  */
+
+  if (uname(&platform))
+  {
+    fprintf(stderr, "ERROR: Can't get platform information: %s\n", strerror(errno));
+
+    return (1);
+  }
+
+  snprintf(pkgname, sizeof(pkgname), "%s-%s-%s-%s.tgz", prodfull,
+           dist->version, platform.machine, dist->release);
+
+ /*
+  * Make a copy of the distribution files...
+  */
+
+  if (Verbosity)
+    puts("Copying temporary distribution files...");
+
+  for (i = dist->num_files, file = dist->files; i > 0; i --, file ++)
+  {
+   /*
+    * Check subpackage...
+    */
+
+    if (file->subpackage != subpackage)
+      continue;
+
+   /*
+    * Find the user and group IDs...
+    */
+
+    pwd = getpwnam(file->user);
+    grp = getgrnam(file->group);
+
+    endpwent();
+    endgrent();
+
+   /*
+    * Copy the file, make the directory, or make the symlink as needed...
+    */
+
+    switch (tolower(file->type))
+    {
+      case 'c' :
+      case 'f' :
+	  snprintf(filename, sizeof(filename), "%s/%s%s", directory, prodfull,
+	           file->dst);
+
+	  if (Verbosity > 1)
+	    printf("F %s -> %s...\n", file->src, filename);
+
+	  if (copy_file(filename, file->src, file->mode, pwd ? pwd->pw_uid : 0,
+	                grp ? grp->gr_gid : 0))
+	    return (1);
+	  break;
+
+      case 'i' :
+	  snprintf(filename, sizeof(filename), "%s/%s/etc/rc.d/%s", directory,
+		   prodfull, file->dst);
+
+	  if (Verbosity > 1)
+	    printf("I %s -> %s...\n", file->src, filename);
+
+	  if (copy_file(filename, file->src, file->mode, pwd ? pwd->pw_uid : 0,
+			grp ? grp->gr_gid : 0))
+	    return (1);
+	  break;
+
+      case 'd' :
+	  snprintf(filename, sizeof(filename), "%s/%s%s", directory, prodfull,
+	           file->dst);
+
+	  if (Verbosity > 1)
+	    printf("D %s...\n", filename);
+
+	  make_directory(filename, file->mode, pwd ? pwd->pw_uid : 0,
+			 grp ? grp->gr_gid : 0);
+	  break;
+
+      case 'l' :
+	  snprintf(filename, sizeof(filename), "%s/%s%s", directory, prodfull,
+	           file->dst);
+
+	  if (Verbosity > 1)
+	    printf("L %s -> %s...\n", file->src, filename);
+
+	  make_link(filename, file->src);
+	  break;
+    }
+  }
+
+ /*
+  * Write descriptions and post-install commands as needed...
+  */
+
+  for (i = 0; i < dist->num_descriptions; i ++)
+    if (dist->descriptions[i].subpackage == subpackage)
+      break;
+
+  if (i < dist->num_descriptions)
+  {
+    snprintf(filename, sizeof(filename), "%s/%s/install", directory, prodfull);
+    make_directory(filename, 0755, 0, 0);
+
+    strlcat(filename, "/slack-desc", sizeof(filename));
+
+    if ((fp = fopen(filename, "w")) == NULL)
+    {
+      fprintf(stderr, "ERROR: Couldn't create Slackware description file \"%s\": %s\n", filename, strerror(errno));
+      return (1);
+    }
+
+    fprintf(fp, "%s: %s\n%s:\n", prodfull, dist->product, prodfull);
+
+    for (; i < dist->num_descriptions; i ++)
+      if (dist->descriptions[i].subpackage == subpackage)
+        fprintf(fp, "%s: %s\n", prodfull, dist->descriptions[i].description);
+
+    fprintf(fp, "%s:\n", prodfull);
+    fprintf(fp, "%s: (Vendor: %s, Packager: %s)\n", prodfull, dist->vendor,
+            dist->packager);
+    fprintf(fp, "%s:\n", prodfull);
+
+    fclose(fp);
+  }
+
+  for (i = 0, c = dist->commands; i < dist->num_commands; i ++, c ++)
+    if (c->subpackage == subpackage)
+      break;
+
+  if (i < dist->num_commands)
+  {
+    snprintf(filename, sizeof(filename), "%s/%s/install", directory, prodfull);
+    make_directory(filename, 0755, 0, 0);
+
+    strlcat(filename, "/doinst.sh", sizeof(filename));
+
+    if (!(fp = fopen(filename, "w")))
+    {
+      fprintf(stderr, "ERROR: Couldn't create post install script \"%s\": %s\n", filename, strerror(errno));
+      return (1);
+    }
+
+    fputs("#!/bin/sh\n", fp);
+
+    for (i = 0, c = dist->commands; i < dist->num_commands; i ++, c ++)
+      if (c->subpackage == subpackage)
+      {
+	switch (c->type)
+	{
+	  case COMMAND_PRE_INSTALL :
+	      fputs("WARNING: Package contains pre-install commands which are not supported\n"
+		    "         by the Slackware packager.\n", stderr);
+	      break;
+
+	  case COMMAND_POST_INSTALL :
+	      fprintf(fp, "%s\n", c->command);
+	      break;
+
+	  case COMMAND_PRE_REMOVE :
+	      fputs("WARNING: Package contains pre-removal commands which are not supported\n"
+		    "         by the Slackware packager.\n", stderr);
+	      break;
+
+	  case COMMAND_POST_REMOVE :
+	      fputs("WARNING: Package contains post-removal commands which are not supported\n"
+		    "         by the Slackware packager.\n", stderr);
+	      break;
+	}
+      }
+
+    fclose(fp);
+  }
+
+ /*
+  * Remove any existing package of the same name, then create the
+  * package...
+  */
+
+  snprintf(filename, sizeof(filename), "%s/%s", directory, pkgname);
+  unlink(filename);
+
+  if (Verbosity)
+    puts("Building Slackware package...");
+
+  snprintf(filename, sizeof(filename), "%s/%s", directory, prodfull);
+
+  if (run_command(filename, "makepkg --linkadd y --chown n ../%s", pkgname))
+    return (1);
+
+ /*
+  * Remove temporary files...
+  */
+
+  if (!KeepFiles)
+  {
+    if (Verbosity)
+      puts("Removing temporary distribution files...");
+
+    unlink_directory(filename);
+  }
+
+  return (0);
+}
diff --git a/./epm/swinstall.c b/./epm/swinstall.c
new file mode 100644
index 0000000..1bf9d30
--- /dev/null
+++ b/./epm/swinstall.c
@@ -0,0 +1,735 @@
+/*
+ * HP-UX package gateway for the ESP Package Manager (EPM).
+ *
+ * Copyright 1999-2017 by Michael R Sweet
+ * Copyright 1999-2010 by Easy Software Products.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "epm.h"
+
+
+/*
+ * Local functions...
+ */
+
+static void	write_fileset(FILE *fp, dist_t *dist, const char *directory,
+		              const char *prodname, const char *subpackage);
+
+
+/*
+ * 'make_swinstall()' - Make an HP-UX software distribution package.
+ */
+
+int					/* O - 0 = success, 1 = fail */
+make_swinstall(const char     *prodname,/* I - Product short name */
+               const char     *directory,
+					/* I - Directory for distribution files */
+               const char     *platname,/* I - Platform name */
+               dist_t         *dist,	/* I - Distribution information */
+	       struct utsname *platform)/* I - Platform information */
+{
+  int		i, j;			/* Looping vars */
+  FILE		*fp;			/* Spec/script file */
+  tarf_t	*tarfile;		/* .tardist file */
+  int		linknum;		/* Symlink number */
+  const char	*vendor;		/* Pointer into vendor name */
+  char		vtag[65],		/* Vendor tag */
+		*vtagptr;		/* Pointer into vendor tag */
+  char		name[1024];		/* Full product name */
+  char		infoname[1024],		/* Info filename */
+		preinstall[1024],	/* preinstall script */
+		postinstall[1024],	/* postinstall script */
+		preremove[1024],	/* preremove script */
+		postremove[1024];	/* postremove script */
+  char		filename[1024];		/* Destination filename */
+  file_t	*file;			/* Current distribution file */
+  command_t	*c;			/* Current command */
+  const char	*runlevels;		/* Run levels */
+
+
+  REF(platform);
+
+  if (Verbosity)
+    puts("Creating swinstall distribution...");
+
+  if (dist->release[0])
+  {
+    if (platname[0])
+      snprintf(name, sizeof(name), "%s-%s-%s-%s", prodname,
+               dist->version, dist->release, platname);
+    else
+      snprintf(name, sizeof(name), "%s-%s-%s", prodname,
+               dist->version, dist->release);
+  }
+  else if (platname[0])
+    snprintf(name, sizeof(name), "%s-%s-%s", prodname, dist->version, platname);
+  else
+    snprintf(name, sizeof(name), "%s-%s", prodname, dist->version);
+
+ /*
+  * Write the preinstall script if needed...
+  */
+
+  for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+    if (c->type == COMMAND_PRE_INSTALL)
+      break;
+
+  if (i)
+  {
+   /*
+    * Create the preinstall script...
+    */
+
+    snprintf(preinstall, sizeof(preinstall), "%s/%s.preinst", directory,
+             prodname);
+
+    if (Verbosity)
+      puts("Creating preinstall script...");
+
+    if ((fp = fopen(preinstall, "w")) == NULL)
+    {
+      fprintf(stderr, "epm: Unable to create script file \"%s\": %s\n", preinstall, strerror(errno));
+      return (1);
+    }
+
+    fchmod(fileno(fp), 0755);
+
+    fputs("#!/bin/sh\n", fp);
+    fputs("# " EPM_VERSION "\n", fp);
+
+    for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+      if (c->type == COMMAND_PRE_INSTALL)
+        fprintf(fp, "%s\n", c->command);
+
+    fclose(fp);
+  }
+  else
+    preinstall[0] = '\0';
+
+ /*
+  * Write the postinstall script if needed...
+  */
+
+  for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+    if (c->type == COMMAND_POST_INSTALL)
+      break;
+
+  if (!i)
+    for (i = dist->num_files, file = dist->files; i > 0; i --, file ++)
+      if (tolower(file->type) == 'i')
+        break;
+
+  if (i)
+  {
+   /*
+    * Create the postinstall script...
+    */
+
+    snprintf(postinstall, sizeof(postinstall), "%s/%s.postinst", directory,
+             prodname);
+
+    if (Verbosity)
+      puts("Creating postinstall script...");
+
+    if ((fp = fopen(postinstall, "w")) == NULL)
+    {
+      fprintf(stderr, "epm: Unable to create script file \"%s\": %s\n", postinstall, strerror(errno));
+      return (1);
+    }
+
+    fchmod(fileno(fp), 0755);
+
+    fputs("#!/bin/sh\n", fp);
+    fputs("# " EPM_VERSION "\n", fp);
+
+    for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+      if (c->type == COMMAND_POST_INSTALL)
+        fprintf(fp, "%s\n", c->command);
+
+    for (i = dist->num_files, file = dist->files; i > 0; i --, file ++)
+      if (tolower(file->type) == 'i')
+	qprintf(fp, "/sbin/init.d/%s start\n", file->dst);
+
+    fclose(fp);
+  }
+  else
+    postinstall[0] = '\0';
+
+ /*
+  * Write the preremove script if needed...
+  */
+
+  for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+    if (c->type == COMMAND_PRE_REMOVE)
+      break;
+
+  if (!i)
+    for (i = dist->num_files, file = dist->files; i > 0; i --, file ++)
+      if (tolower(file->type) == 'i')
+        break;
+
+  if (i)
+  {
+   /*
+    * Then create the remove script...
+    */
+
+    if (Verbosity)
+      puts("Creating preremove script...");
+
+    snprintf(preremove, sizeof(preremove), "%s/%s.prerm", directory, prodname);
+
+    if ((fp = fopen(preremove, "w")) == NULL)
+    {
+      fprintf(stderr, "epm: Unable to create script file \"%s\": %s\n", preremove, strerror(errno));
+      return (1);
+    }
+
+    fchmod(fileno(fp), 0755);
+
+    fputs("#!/bin/sh\n", fp);
+    fputs("# " EPM_VERSION "\n", fp);
+
+    for (j = dist->num_files, file = dist->files; j > 0; j --, file ++)
+      if (tolower(file->type) == 'i')
+	qprintf(fp, "/sbin/init.d/%s stop\n", file->dst);
+
+    for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+      if (c->type == COMMAND_PRE_REMOVE)
+        fprintf(fp, "%s\n", c->command);
+
+    fclose(fp);
+  }
+  else
+    preremove[0] = '\0';
+
+ /*
+  * Write the postremove script if needed...
+  */
+
+  for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+    if (c->type == COMMAND_POST_REMOVE)
+      break;
+
+  if (i)
+  {
+   /*
+    * Create the postremove script...
+    */
+
+    snprintf(postremove, sizeof(postremove), "%s/%s.postrm", directory,
+             prodname);
+
+    if (Verbosity)
+      puts("Creating postremove script...");
+
+    if ((fp = fopen(postremove, "w")) == NULL)
+    {
+      fprintf(stderr, "epm: Unable to create script file \"%s\": %s\n", postremove, strerror(errno));
+      return (1);
+    }
+
+    fchmod(fileno(fp), 0755);
+
+    fputs("#!/bin/sh\n", fp);
+    fputs("# " EPM_VERSION "\n", fp);
+
+    for (i = dist->num_commands, c = dist->commands; i > 0; i --, c ++)
+      if (c->type == COMMAND_POST_REMOVE)
+        fprintf(fp, "%s\n", c->command);
+
+    fclose(fp);
+  }
+  else
+    postremove[0] = '\0';
+
+ /*
+  * Add symlinks for init scripts...
+  */
+
+  for (i = 0; i < dist->num_files; i ++)
+    if (tolower(dist->files[i].type) == 'i')
+    {
+     /*
+      * Make symlinks for all of the selected run levels...
+      */
+
+      for (runlevels = get_runlevels(dist->files + i, "02");
+           isdigit(*runlevels & 255);
+	   runlevels ++)
+      {
+	file = add_file(dist, dist->files[i].subpackage);
+	file->type = 'l';
+	file->mode = 0;
+	strlcpy(file->user, "root", sizeof(file->user));
+	strlcpy(file->group, "sys", sizeof(file->group));
+	snprintf(file->src, sizeof(file->src), "../init.d/%s",
+        	 dist->files[i].dst);
+
+        if (*runlevels == '0')
+	  snprintf(file->dst, sizeof(file->dst), "/sbin/rc0.d/K%02d0%s",
+        	   get_stop(dist->files + i, 0), dist->files[i].dst);
+        else
+	  snprintf(file->dst, sizeof(file->dst), "/sbin/rc%c.d/S%02d0%s",
+        	   *runlevels, get_start(dist->files + i, 99),
+		   dist->files[i].dst);
+      }
+
+     /*
+      * Then send the original file to /sbin/init.d...
+      */
+
+      file = dist->files + i;
+
+      snprintf(filename, sizeof(filename), "/sbin/init.d/%s", file->dst);
+      strlcpy(file->dst, filename, sizeof(file->dst));
+    }
+
+ /*
+  * Create all symlinks...
+  */
+
+  if (Verbosity)
+    puts("Creating symlinks...");
+
+  for (i = dist->num_files, file = dist->files, linknum = 0;
+       i > 0;
+       i --, file ++)
+    if (tolower(file->type) == 'l')
+    {
+      snprintf(filename, sizeof(filename), "%s/%s.link%04d", directory,
+               prodname, linknum);
+      symlink(file->src, filename);
+      linknum ++;
+    }
+
+ /*
+  * Write the description file(s) for swpackage...
+  */
+
+  if (dist->num_descriptions > 0)
+  {
+    if (Verbosity)
+      puts("Creating description file(s)...");
+
+    for (i = 0; i < dist->num_descriptions; i ++)
+      if (!dist->descriptions[i].subpackage)
+        break;
+
+    if (i < dist->num_descriptions)
+    {
+      snprintf(filename, sizeof(filename), "%s/%s.desc", directory, prodname);
+
+      if ((fp = fopen(filename, "w")) == NULL)
+      {
+	fprintf(stderr, "epm: Unable to create description file \"%s\": %s\n", filename, strerror(errno));
+	return (1);
+      }
+
+      for (; i < dist->num_descriptions; i ++)
+	if (!dist->descriptions[i].subpackage)
+	  fprintf(fp, "%s\n", dist->descriptions[i].description);
+
+      fclose(fp);
+    }
+
+    for (i = 0; i < dist->num_subpackages; i ++)
+    {
+      for (j = 0; j < dist->num_descriptions; j ++)
+	if (dist->descriptions[j].subpackage == dist->subpackages[i])
+          break;
+
+      if (j < dist->num_descriptions)
+      {
+	snprintf(filename, sizeof(filename), "%s/%s-%s.desc", directory,
+        	 prodname, dist->subpackages[i]);
+
+	if ((fp = fopen(filename, "w")) == NULL)
+	{
+	  fprintf(stderr, "epm: Unable to create description file \"%s\": %s\n", filename, strerror(errno));
+	  return (1);
+	}
+
+	for (; j < dist->num_descriptions; j ++)
+	  if (dist->descriptions[j].subpackage == dist->subpackages[i])
+	    fprintf(fp, "%s\n", dist->descriptions[j].description);
+
+	fclose(fp);
+      }
+    }
+  }
+
+ /*
+  * Write the info file for swpackage...
+  */
+
+  if (Verbosity)
+    puts("Creating info file...");
+
+  snprintf(infoname, sizeof(infoname), "%s/%s.info", directory, prodname);
+
+  if ((fp = fopen(infoname, "w")) == NULL)
+  {
+    fprintf(stderr, "epm: Unable to create info file \"%s\": %s\n", infoname, strerror(errno));
+    return (1);
+  }
+
+ /*
+  * Figure out the vendor tag and write a vendor class...
+  */
+
+  for (vendor = dist->vendor, vtagptr = vtag; *vendor; vendor ++)
+    if (isalnum(*vendor) && vtagptr < (vtag + sizeof(vtag) - 1))
+      *vtagptr++ = *vendor;
+
+  *vtagptr = '\0';
+
+  fputs("vendor\n", fp);
+  fprintf(fp, "  tag %s\n", vtag);
+  fprintf(fp, "  description %s\n", dist->vendor);
+  fprintf(fp, "  title %s\n", dist->vendor);
+  fputs("end\n", fp);
+
+ /*
+  * Then the product class...
+  */
+
+  fputs("product\n", fp);
+  fprintf(fp, "  tag %s\n", prodname);
+  fprintf(fp, "  revision %s\n", dist->version);
+  fprintf(fp, "  title %s, %s\n", dist->product, dist->version);
+
+  snprintf(filename, sizeof(filename), "%s/%s.desc", directory, prodname);
+  if (!access(filename, 0))
+    fprintf(fp, "  description < %s\n", filename);
+  if (dist->license[0])
+  {
+    if (strncmp(dist->license, "./", 2))
+      fprintf(fp, "  copyright < %s\n", dist->license);
+    else
+      fprintf(fp, "  copyright < %s\n", dist->license + 2);
+  }
+  if (dist->readme[0])
+  {
+    if (strncmp(dist->readme, "./", 2))
+      fprintf(fp, "  readme < %s\n", dist->readme);
+    else
+      fprintf(fp, "  readme < %s\n", dist->readme + 2);
+  }
+  fprintf(fp, "  vendor_tag %s\n", vtag);
+  fputs("  is_locatable false\n", fp);
+
+  if (dist->num_subpackages > 0)
+  {
+   /*
+    * Write subproduct specifications...
+    */
+
+    fputs("  subproduct\n", fp);
+    fputs("    tag base\n", fp);
+    fputs("    contents fs_base\n", fp);
+    fprintf(fp, "    revision %s\n", dist->version);
+
+    for (i = 0; i < dist->num_descriptions; i ++)
+      if (!dist->descriptions[i].subpackage)
+      {
+        fprintf(fp, "    title %s, %s\n", dist->descriptions[i].description,
+	        dist->version);
+        break;
+      }
+
+    if (!access(filename, 0))
+      fprintf(fp, "    description < %s\n", filename);
+    fputs("  end\n", fp);
+
+    for (i = 0; i < dist->num_subpackages; i ++)
+    {
+      fputs("  subproduct\n", fp);
+      fprintf(fp, "    tag %s\n", dist->subpackages[i]);
+      fprintf(fp, "    contents fs_%s\n", dist->subpackages[i]);
+      fprintf(fp, "    revision %s\n", dist->version);
+
+      for (j = 0; j < dist->num_descriptions; j ++)
+	if (dist->descriptions[j].subpackage == dist->subpackages[i])
+	{
+          fprintf(fp, "    title %s, %s\n", dist->descriptions[j].description,
+	          dist->version);
+          break;
+	}
+
+      snprintf(filename, sizeof(filename), "%s/%s-%s.desc", directory,
+               prodname, dist->subpackages[i]);
+      if (!access(filename, 0))
+	fprintf(fp, "    description < %s\n", filename);
+      fputs("  end\n", fp);
+    }
+  }
+
+ /*
+  * Write filesets...
+  */
+
+  write_fileset(fp, dist, directory, prodname, NULL);
+  for (i = 0; i < dist->num_subpackages; i ++)
+    write_fileset(fp, dist, directory, prodname, dist->subpackages[i]);
+
+  fputs("end\n", fp);
+
+  fclose(fp);
+
+ /*
+  * Build the distributions from the spec file...
+  */
+
+  if (Verbosity)
+    puts("Building swinstall depot.gz distribution...");
+
+  snprintf(filename, sizeof(filename), "%s/%s", directory, prodname);
+  mkdir(filename, 0777);
+
+  if (run_command(NULL, "/usr/sbin/swpackage %s-s %s "
+                        "-x target_type=tape "
+			"-d '|" EPM_GZIP " -9 >%s/%s.depot.gz' %s",
+        	  Verbosity == 0 ? "" : "-v ", infoname, directory,
+		  name, prodname))
+    return (1);
+
+  if (Verbosity)
+    puts("Building swinstall binary distribution...");
+
+  snprintf(filename, sizeof(filename), "%s/%s", directory, prodname);
+  mkdir(filename, 0777);
+
+  if (run_command(NULL, "/usr/sbin/swpackage %s-s %s -d %s/%s "
+                        "-x write_remote_files=true %s",
+        	  Verbosity == 0 ? "" : "-v ", infoname, directory,
+		  prodname, prodname))
+    return (1);
+
+ /*
+  * Tar and compress the distribution...
+  */
+
+  if (Verbosity)
+    puts("Creating depot.tgz file for distribution...");
+
+  snprintf(filename, sizeof(filename), "%s/%s.depot.tgz", directory, name);
+
+  if ((tarfile = tar_open(filename, 1)) == NULL)
+    return (1);
+
+  snprintf(filename, sizeof(filename), "%s/%s", directory, prodname);
+
+  if (tar_directory(tarfile, filename, prodname))
+  {
+    tar_close(tarfile);
+    return (1);
+  }
+
+  tar_close(tarfile);
+
+ /*
+  * Remove temporary files...
+  */
+
+  if (!KeepFiles)
+  {
+    if (Verbosity)
+      puts("Removing temporary distribution files...");
+
+    unlink(infoname);
+
+    if (preinstall[0])
+      unlink(preinstall);
+    if (postinstall[0])
+      unlink(postinstall);
+    if (preremove[0])
+      unlink(preremove);
+    if (postremove[0])
+      unlink(postremove);
+
+    while (linknum > 0)
+    {
+      linknum --;
+      snprintf(filename, sizeof(filename), "%s/%s.link%04d", directory,
+               prodname, linknum);
+      unlink(filename);
+    }
+
+    snprintf(filename, sizeof(filename), "%s/%s.desc", directory, prodname);
+    unlink(filename);
+
+    for (i = 0; i < dist->num_subpackages; i ++)
+    {
+      snprintf(filename, sizeof(filename), "%s/%s-%s.desc", directory,
+               prodname, dist->subpackages[i]);
+      unlink(filename);
+    }
+  }
+
+  return (0);
+}
+
+
+/*
+ * 'write_fileset()' - Write a fileset specification for a subpackage.
+ */
+
+static void
+write_fileset(FILE       *fp,		/* I - File to write to */
+              dist_t     *dist,		/* I - Distribution */
+	      const char *directory,	/* I - Output directory */
+	      const char *prodname,	/* I - Product name */
+	      const char *subpackage)	/* I - Subpackage to write */
+{
+  int		i;			/* Looping var */
+  char		filename[1024];		/* Temporary filename */
+  depend_t	*d;			/* Current dependency */
+  file_t	*file;			/* Current distribution file */
+  int		linknum;		/* Symlink number */
+
+
+  fputs("  fileset\n", fp);
+  fprintf(fp, "    tag fs_%s\n", subpackage ? subpackage : "base");
+  fprintf(fp, "    revision %s\n", dist->version);
+
+  for (i = 0; i < dist->num_descriptions; i ++)
+    if (dist->descriptions[i].subpackage == subpackage)
+    {
+      fprintf(fp, "    title %s, %s\n", dist->descriptions[i].description,
+              dist->version);
+      break;
+    }
+
+  for (i = dist->num_depends, d = dist->depends; i > 0; i --, d ++)
+    if (d->type == DEPEND_REQUIRES && d->product[0] != '/' &&
+        d->subpackage == subpackage)
+      break;
+
+  if (i)
+  {
+    for (; i > 0; i --, d ++)
+    {
+      if (d->type == DEPEND_REQUIRES && d->product[0] != '/' &&
+          d->subpackage == subpackage)
+      {
+        if (!strcmp(d->product, "_self"))
+	  fprintf(fp, "    prerequisites %s", prodname);
+	else
+	  fprintf(fp, "    prerequisites %s", d->product);
+
+	if (d->vernumber[0] == 0)
+	{
+	  if (d->vernumber[1] < INT_MAX)
+            fprintf(fp, ",r<=%s\n", d->version[1]);
+	  else
+	    putc('\n', fp);
+	}
+	else
+	  fprintf(fp, ",r>=%s,r<=%s\n", d->version[0], d->version[1]);
+      }
+    }
+  }
+
+  for (i = dist->num_depends, d = dist->depends; i > 0; i --, d ++)
+    if (d->type == DEPEND_REPLACES && d->product[0] != '/' &&
+        d->subpackage == subpackage)
+      break;
+
+  if (i)
+  {
+    for (; i > 0; i --, d ++)
+    {
+      if (d->type == DEPEND_REPLACES && d->product[0] != '/' &&
+          d->subpackage == subpackage)
+      {
+        fprintf(fp, "    ancestor %s", d->product);
+	if (d->vernumber[0] == 0)
+	{
+	  if (d->vernumber[1] < INT_MAX)
+            fprintf(fp, ",r<=%s\n", d->version[1]);
+	  else
+	    putc('\n', fp);
+	}
+	else
+	  fprintf(fp, ",r>=%s,r<=%s\n", d->version[0], d->version[1]);
+      }
+    }
+  }
+
+  if (!subpackage)
+  {
+   /*
+    * Write scripts...
+    */
+
+    snprintf(filename, sizeof(filename), "%s/%s.preinst", directory, prodname);
+    if (!access(filename, 0))
+      fprintf(fp, "    preinstall %s\n", filename);
+
+    snprintf(filename, sizeof(filename), "%s/%s.postinst", directory, prodname);
+    if (!access(filename, 0))
+      fprintf(fp, "    postinstall %s\n", filename);
+
+    snprintf(filename, sizeof(filename), "%s/%s.prerm", directory, prodname);
+    if (!access(filename, 0))
+      fprintf(fp, "    preremove %s\n", filename);
+
+    snprintf(filename, sizeof(filename), "%s/%s.postrm", directory, prodname);
+    if (!access(filename, 0))
+      fprintf(fp, "    postremove %s\n", filename);
+  }
+
+  for (i = dist->num_files, file = dist->files, linknum = 0;
+       i > 0;
+       i --, file ++)
+  {
+    if (file->subpackage != subpackage)
+    {
+      if (tolower(file->type) == 'l')
+        linknum ++;
+
+      continue;
+    }
+
+    switch (tolower(file->type))
+    {
+      case 'd' :
+          qprintf(fp, "    file -m %04o -o %s -g %s . %s\n", file->mode,
+	          file->user, file->group, file->dst);
+          break;
+      case 'c' :
+          qprintf(fp, "    file -m %04o -o %s -g %s -v %s %s\n", file->mode,
+	          file->user, file->group, file->src, file->dst);
+          break;
+      case 'f' :
+      case 'i' :
+          qprintf(fp, "    file -m %04o -o %s -g %s %s %s\n", file->mode,
+	          file->user, file->group, file->src, file->dst);
+          break;
+      case 'l' :
+          snprintf(filename, sizeof(filename), "%s/%s.link%04d", directory,
+	           prodname, linknum);
+          linknum ++;
+          qprintf(fp, "    file -o %s -g %s %s %s\n", file->user, file->group,
+	          filename, file->dst);
+          break;
+    }
+  }
+
+  fputs("  end\n", fp);
+}
